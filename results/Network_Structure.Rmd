---
title: "Network Structure"
author: "Kyra Bankhead"
date: "2023-03-02"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this markdown I will:

1. Create the network structure for the association matrix.

2. Evaluate local and global network metrics.

3. Evaluate modularity.


# PART 1: *Network Structure*

```{r network, echo=TRUE, message=FALSE, warning=FALSE}
# Read in social association matrix
setwd("C:/Users/bankh/My_Repos/Dolphins/data")
gbi<- read.csv("gbi.csv")
source("../code/functions.R") # SRI & null permutation
nxn<- SRI.func(gbi)
nxn<-as.matrix(nxn)
## load all necessary packages
require(igraph)

## Create social network
ig <- graph_from_adjacency_matrix(as.matrix(nxn),
                                  mode = c("undirected"),
                                  weighted = TRUE,
                                  diag = F, # No loops
                                  add.colnames = T,
                                  add.rownames = NA)

# Plot network
plot(ig,
     layout = layout_with_fr(ig),
     # link weight, rescaled for better visualization
     edge.width= E(ig)$weight*4,
     # node size as degree (rescaled)
     vertex.size= sqrt(igraph::strength(ig, vids = V(ig), mode = c("all"), loops = TRUE) *10 ),
     vertex.frame.color= NA, #"black",
     vertex.label.family = "Helvetica",
     vertex.label.color="black", 
     vertex.label.cex=0.8, 
     vertex.label.dist=2, 
     # edge.curved=0,
     vertex.frame.width=0.01,
)

```

# PART 2: *Network Metrics*

## Local Network Metrics

- Local clustering coeffcient: Measure of the prevalence of node clusters in a network.

- Betweeness: A high betweenness means that the individual is in the communication path of other individuals, therefore, the individuals it interacts with, depend on its presence.

- Closeness: The larger the closeness centrality is for an individual, the more rapidly and easily it can influence the behavior of others.

- Degree: # Individual’s associates

- Strength: Total strength of an individuals’ associations

```{r lmetrics}
# Edgelist: Nodes (i & j) and edge (or link) weight
el <- matrix_to_edgelist(nxn, rawdata = FALSE, idnodes = FALSE)

# Centrality measures
# Weighted clustering coefficients
clustering_local_w(el, measure=c("am", "gm", "mi", "ma", "bi"))

## Betweenness centrality
betweenness_w(el, alpha=1)       

# Closeness centrality
closeness_w(el, alpha=1)

# Degree and strength centrality
degree_w(el, measure=c("degree","strength"), type="out", alpha=1)


```

# Global Network Metrics

- Size: Number of nodes.

- Density/Connectance: Proportion of realized links (observed/possible links).

- Average Path Length (geodesic): Measures the shortest distance between two random nodes then average shortest pathways between all pairs of nodes. Shows how far apart any pair of individuals will be on average.

- Geodesic path: the shortest path through the network from one node to another (l).

- Diameter: Length of the longest geodesic path (d).

- Clustering coefficient: Tendency of nodes to cluster in the network (Are the friends’ friends also friends?).


```{r gmetrics}
#' Size
N = nrow(nxn)
#' Number of possible links: 
#' Nodes*(Nodes-1)/2: (-1 removes the node itself; /2 removes repetitions)
total = N*(N-1)/2
# Number of realized links: all non-zero cells in the association matrix
real = length(which(as.dist(nxn)!=0))
# Connectance: realized/total
real/total

# Shortest path lengths (geodesics) and diameter
# all binary shortest path lengths between nodes
distances(ig)

# mean shortest path
mean_distance(ig)

# Binary shortest path lengths
distance_table(ig, directed=FALSE)

# All Weighted Shortest path lenghts (or geodesics)
distance_w(el)
# weighted diameter
max(as.dist(distance_w(el)))

# Clustering coefficients
clustering_w (el, measure=c("am", "gm", "mi", "ma", "bi")) 

```

# PART 3: *Modularity*

- Newman's Q modularity: Stopping parameter Q removes links according to the betweenness. 

```{r modular}
# Create a network from the first two columns
dolp_ig <- graph.edgelist(el[,1:2])
# Add the edge weights to this network by assigning an edge attribute called 'weight'.
E(dolp_ig)$weight <- as.numeric(el[,3])
# Create undirect network
dolp_ig <- as.undirected(dolp_ig)

# Plot
plot(dolp_ig, edge.width=E(dolp_ig)$weight*4, vertex.size=10, vertex.label=NA, edge.curved=F)

# Newman's Q modularity
newman <- cluster_leading_eigen(dolp_ig, steps = -1, weights = E(dolp_ig)$weight, 
                                start = NULL, options = arpack_defaults, callback = NULL, 
                                extra = NULL, env = parent.frame())

# Assign a random color to individuals of each module ('modules')
col <- rgb(runif(10), runif(10), runif(10))
newman$membership

for (i in 1:max(newman$membership)){
  sample(col)
  V(dolp_ig)$color[which(newman$membership==i)] = col[i]
}
plot(dolp_ig)

```

Since these modules can represent functional units, I need to test which mechanisms drive the modular topology by creating null models.