---
title: "Network Structure"
author: "Kyra Bankhead"
date: "2023-03-02"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this markdown I will:

1. Create the network structure from the association matrix.

2. Evaluate local and global network metrics.

3. Permutate the link weights using the WalkTrap algorithm.

4. Evaluate and plot modularity.


# PART 1: *Network Structure*

```{r data, message=FALSE, warning=FALSE, include=FALSE}
## load all necessary packages
require(igraph) # Look at Dai Shizuka/Jordi Bascompte
require(tnet) # For weights
require(sna)
require(statnet)
library(doParallel) # For faster computing

# Read in social association matrix
setwd("../data")
# Add helpful functions
source("../code/functions.R") # edgelist function

# Read in social association matrix
nxn <- readRDS("nxn.RData")
list_years <- readRDS("list_years.RData")

```


```{r network, echo=TRUE, message=FALSE, warning=FALSE}

# Test one year at a time
year <- 1

## Create social network
ig <- lapply(nxn, function (df) {
  graph_from_adjacency_matrix(
  df,
  mode = "undirected",
  weighted = TRUE,
  diag = FALSE)})

# Set the node names based on row names
row_names <- lapply(nxn, function (df) {rownames(df)})
for (i in seq_along(ig)) {
  V(ig[[i]])$name <- row_names[[i]]
}

# Plot network
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
par(mfrow=c(1, 2))

# Loop through the list of graphs and plot them side by side
for (i in 1:length(ig)) {
  plot(ig[[i]],
       layout = layout_with_fr(ig[[i]]),
       edge.width = E(ig[[i]])$weight * 4,
       vertex.size = sqrt(igraph::strength(ig[[i]], vids = V(ig[[i]]), mode = c("all"), loops = TRUE) * 10),
       vertex.frame.color = NA,
       vertex.label.family = "Helvetica",
       vertex.label = V(ig[[i]])$name,
       vertex.label.color = "black",
       vertex.label.cex = 0.8,
       vertex.label.dist = 2,
       vertex.frame.width = 0.01)
}

# rasterImage(img.3, xleft=0, xright=1.9, ybottom=0, ytop=1.5)

# Reset the plotting area to its default configuration
par(mfrow=c(1, 1))

```


# PART 2: *Network Metrics*

## Local Network Metrics

- Local clustering coefficient: Measure of the prevalence of node clusters in a network.

- Betweeness: A high betweenness means that the individual is in the communication path of other individuals, therefore, the individuals it interacts with, depend on its presence.

- Closeness: The larger the closeness centrality is for an individual, the more rapidly and easily it can influence the behavior of others.

- Degree: # Individual’s associates

- Strength: Total strength of an individuals’ associations

```{r lmetrics, echo=TRUE, message=FALSE, warning=FALSE}
# Edgelist: Nodes (i & j) and edge (or link) weight
n.cores <- detectCores()
system.time({
  registerDoParallel(n.cores)
  el_years <- list()
  for (i in seq_along(list_years)) {
    el_years[[i]] <- matrix_to_edgelist(nxn[[i]], rawdata = FALSE, idnodes = FALSE)
  }  
  ### End parallel processing
  stopImplicitCluster()
})

saveRDS(el_years, "el_years.RData")
el <- readRDS("el_years.RData")

# Centrality measures
# Weighted clustering coefficients
cluster <- lapply(el, function (df) {clustering_local_w(df, measure=c("am", "gm", "mi", "ma", "bi"))})

## Betweenness centrality
between <- lapply(el, function (df) {betweenness_w(df, alpha=1)})

# Closeness centrality
close <- lapply(el, function (df) {closeness_w(df, alpha=1)})

# Degree and strength centrality
strength <- lapply(el, function (df) {degree_w(df, measure=c("degree","output"), type="out", alpha=1)})


```

# Global Network Metrics

- Size: Number of nodes.

- Density/Connectance: Proportion of realized links (observed/possible links).

- Average Path Length (geodesic): Measures the shortest distance between two random nodes then average shortest pathways between all pairs of nodes. Shows how far apart any pair of individuals will be on average.

- Geodesic path: the shortest path through the network from one node to another (l).

- Diameter: Length of the longest geodesic path (d).

- Clustering coefficient: Tendency of nodes to cluster in the network (Are the friends’ friends also friends?).


```{r gmetrics, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
#' Breakdown: connectance = length(which(as.dist(orca_hwi)!=0))/(N*(N-1)/2)
#' Number of nodes (number of rows in the association matrix)
N = nrow(nxn[[year]])
#' Number of possible links: 
#' Nodes*(Nodes-1)/2: (-1 removes the node itself; /2 removes repetitions)
total = N*(N-1)/2
# Number of realized links: all non-zero cells in the association matrix
real = length(which(as.dist(nxn[[year]])!=0))
# Connectance: realized/total
real/total

# Shortest path lengths (geodesics) and diameter
# # mean shortest path
dist <- lapply(ig, function(df) {mean_distance(df)})
dist

```


# PART 3: *Permutate Link Weights*

## Walktrap algorithm breakdown with one interation

```{r data, message=FALSE, warning=FALSE, include=FALSE}
## Edgelist
## igraph format with weight
system.time({
  registerDoParallel(n.cores)
  dolphin_ig <- list()
  for (j in seq_along(list_years)) {
    dolphin_ig[[j]] <- graph.adjacency(as.matrix(nxn[[j]]),
                                       mode="undirected",
                                       weighted=TRUE, diag=FALSE)
  }  
  ### End parallel processing
  stopImplicitCluster()
})

```


```{r oneit, message=FALSE, warning=FALSE, include=FALSE}
# Modularity by the WalkTrap algorithm 
system.time({
  registerDoParallel(n.cores)
  dolphin_walk <- list()
  for (k in seq_along(list_years)) {
    dolphin_walk[[k]] <- cluster_walktrap(dolphin_ig[[k]], weights = E(dolphin_ig[[k]])$weight, 
                                     steps = 4, merges = TRUE, modularity = TRUE, membership = TRUE)
  } 
  ### End parallel processing
  stopImplicitCluster()
})

## Modularity Q-value
modularity(dolphin_walk[[year]])
## Number of modules
groups(dolphin_walk[[year]])
## Membership of modules
membership(dolphin_walk[[year]])
## Save the edgelist into a new object
auxrand <- as.data.frame(el[[year]])

# Permutate the link weights
sample(auxrand$vw)
## Save in the auxrand object
auxrand[,3] <- sample(auxrand$vw)

# Calculate the modularity Q-value for a new permutated edge list
## Create a network from the list of nodes
igrand <- graph.edgelist(el[[year]][,1:2]) 
### Add link weights
E(igrand)$weight <- el[[year]][,2]
### Make undirected graph
igrand <- as.undirected(igrand)
## Permutate the link weights
E(igrand)$weight <- sample(E(igrand)$weight)
## Calculate modularity Q-value
rmod <- walktrap.community(igrand)
modularity(rmod)
## Number of modules
groups(rmod)
## Membership of modules
membership(rmod)

# Difference from our empirical data?
modularity(dolphin_walk[[year]])
modularity(rmod)

```


## Permutate with multiple interations

```{r mult, echo=TRUE, message=FALSE, warning=FALSE}
# Run modularity permutations 1000 times
iter = 1000
randmod = numeric()
for(i in 1:iter){
  # Save the edgelist into a new object
  auxrand <- el[[year]]
  # igraph format
  igrand <- graph.edgelist(auxrand[,1:2]) # Create a network from the list of nodes
  E(igrand)$weight <- auxrand[,2] # Add link weights
  igrand <- as.undirected(igrand) # Make undirected graph
  # Permutate the link weights
  E(igrand)$weight <- sample(E(igrand)$weight)
  # calculate the modularity Q-value
  rand_walk <- walktrap.community(igrand)
  randmod[i] <- modularity(rand_walk) # Save Q-value into a vector
}

## Calculate the 95% confidence interval (two-tailed test)
ci = quantile(randmod, probs=c(0.025, 0.975), type=2)

## Compare with the empirical Q-value
data.frame(Q=modularity(dolphin_walk[[year]]), LowCI=ci[1], HighCI=ci[2])

## Visualization random Q distribution
hist(randmod, xlim=c(0,0.6))
### Empirical Q-value
abline(v= modularity(dolphin_walk[[year]]), col="red")
### 2.5% CI
abline(v= ci[1], col="blue")
### 97.5% CI
abline(v= ci[2], col="blue")


```

We can reject the null hypothesis that individuals cluster at random and conclude that there is evidence that modularity is higher than what we would expect by chance. 


# PART 4: *Modularity*

- Newman's Q modularity: Stopping parameter Q removes links according to the betweenness. 

```{r modular, echo=TRUE, message=FALSE, warning=FALSE}
# Create a network from the first two columns
dolp_ig <- graph.edgelist(el[,1:2])
# Add the edge weights to this network by assigning an edge attribute called 'weight'.
E(dolp_ig)$weight <- as.numeric(el[,3])
# Create undirect network
dolp_ig <- as.undirected(dolp_ig)

# Plot
plot(dolp_ig, edge.width=E(dolp_ig)$weight*4, vertex.size=10, vertex.label=NA, edge.curved=F)

# Newman's Q modularity
newman <- cluster_leading_eigen(dolp_ig, steps = -1, weights = E(dolp_ig)$weight, 
                                start = NULL, options = arpack_defaults, callback = NULL, 
                                extra = NULL, env = parent.frame())

# Assign a random color to individuals of each module ('modules')
# Random color scheme
col <- rgb(runif(14), runif(14), runif(14))

V(dolp_ig)$color <- NA
for (i in 1:max(newman$membership)){
  sample(col)
  V(dolp_ig)$color[which(newman$membership==i)] = col[i]
}

plot(dolp_ig)

```

Since these modules can represent functional units, I need to test which mechanisms drive the modular topology by creating null models.