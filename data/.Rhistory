# Plot through time
plot(1:numyears, N_20, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
N_30[1] <- N0
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N_30, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
N_40[1] <- N0
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N_40, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
gc()
# Set working directory here
setwd("../data")
library(brms) # For brm modellibrary(coda)
# Read in data
result_df <- readRDS("result_df.RData")
# Make dummy variables
result_df$BG <- ifelse(result_df$HI == "BG", 1, 0)
result_df$FG <- ifelse(result_df$HI == "FG", 1, 0)
result_df$SD <- ifelse(result_df$HI == "SD", 1, 0)
# Make ID numeric
result_df$numeric_ID <- as.numeric(factor(result_df$ID))
# Make sure there is only one ID in each period
result_df <- result_df[!duplicated(result_df[c("Period", "ID")]), ]
library(rstan) # To make STAN run faster
# Help STAN run faster
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit_brm.1 <- brm(composite_centrality ~ Prop_BG + Prop_FG + Prop_SD +
(1 | numeric_ID), sigma ~ Prop_BG + Prop_FG + Prop_SD +
(1 | numeric_ID),
chains = 3, data = result_df)
fit_brm.1 <- brm(composite_centrality ~ Prop_BG + Prop_FG + Prop_SD +
(1 | numeric_ID), sigma ~ Prop_BG + Prop_FG + Prop_SD +
(1 | numeric_ID),
chains = 3, family = gaussian, data = result_df)
fit_brm.1 <- brm(bf(composite_centrality ~ Prop_BG + Prop_FG + Prop_SD +
(1 | numeric_ID), sigma ~ Prop_BG + Prop_FG + Prop_SD +
(1 | numeric_ID)),
chains = 3, family = gaussian, data = result_df)
summary(fit_brm.1)
# Check for model convergence
model <- fit_brm.1
plot(model)
(1 | numeric_ID), sigma ~ Prop_BG + Prop_FG + Prop_SD),
fit_brm.1 <- brm(bf(composite_centrality ~ Prop_BG + Prop_FG + Prop_SD +
(1 | numeric_ID), sigma ~ Prop_BG + Prop_FG + Prop_SD),
chains = 3, family = gaussian, data = result_df)
summary(fit_brm.1)
# Check for model convergence
model <- fit_brm.1
plot(model)
fit_brm.1 <- brm(bf(composite_centrality ~ Prop_BG + Prop_FG + Prop_SD +
(1 | numeric_ID), sigma ~ 0 + Prop_BG + Prop_FG + Prop_SD),
chains = 3, family = gaussian, data = result_df)
# Check for model convergence
model <- fit_brm.1
plot(model)
summary(fit_brm.1)
pp_check(model) # check to make sure they line up
theme_update(text = element_text(family = "sans"))
library(bayesplot) # plot parameters
library(hrbrthemes) # plot themes
# Create mcmc_areas plot
mcmc_plot <- mcmc_areas(
as.array(model),
pars = c("b_Prop_FG", "b_Prop_BG", "b_Prop_SD",
"b_After", "b_During"),
prob = 0.8, # 80% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) + labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 80% intervals"
) + theme_update(text = element_text(family = "sans"))
theme_update(text = element_text(family = "sans"))
fit_brm.2 <- brm(bf(composite_centrality ~ Prop_BG + Prop_FG + Prop_SD + After + During +
(1 | numeric_ID), sigma ~ 0 + Prop_BG + Prop_FG + Prop_SD),
chains = 3, data = result_df)
# Check for model convergence
model <- fit_brm.2
plot(model)
# Read in data
result_df <- readRDS("result_df.RData")
# Make dummy variables
result_df$BG <- ifelse(result_df$HI == "BG", 1, 0)
result_df$FG <- ifelse(result_df$HI == "FG", 1, 0)
result_df$SD <- ifelse(result_df$HI == "SD", 1, 0)
# Make ID numeric
result_df$numeric_ID <- as.numeric(factor(result_df$ID))
fit_brm.1 <- brm(bf(composite_centrality ~ BG + FG + SD +
(1 | numeric_ID), sigma ~ 0 + BG + FG + SD),
chains = 3, family = gaussian, data = result_df)
# Check for model convergence
model <- fit_brm.1
plot(model)
summary(fit_brm.1)
# Make sure there is only one ID in each period
result_df <- result_df[!duplicated(result_df[c("Period", "ID")]), ]
View(result_df)
fit_brm.1 <- brm(bf(composite_centrality ~ Prop_BG + Prop_FG + Prop_SD +
(1 | numeric_ID), sigma ~ 0 + BG + FG + SD),
chains = 3, family = gaussian, data = result_df)
# Check for model convergence
model <- fit_brm.1
plot(model)
pp_check(model) # check to make sure they line up
summary(fit_brm.1)
fit_brm.2 <- brm(bf(composite_centrality ~ Prop_BG + Prop_FG + Prop_SD + After + During +
(1 | numeric_ID), sigma ~ 0 + BG + FG + SD),
chains = 3, family = gaussian, data = result_df)
# Check for model convergence
model <- fit_brm.2
plot(model)
pp_check(model) # check to make sure they line up
summary(fit_brm.2)
fit_brm.3 <- brm(bf(composite_centrality ~
Prop_BG * During + Prop_BG * After +
Prop_FG * During + Prop_FG * After +
Prop_SD * During + Prop_SD * After +
(1 | numeric_ID), sigma ~ 0 + BG + FG + SD),
chains = 3, family = gaussian, data = result_df)
# Models in brms
fit_brm.0 <- brm(bf(composite_centrality ~ 1 + (1 | numeric_ID)),
chains = 3, family = gaussian, data = result_df)
loo(fit_brm.0, fit_brm.1, fit_brm.2, fit_brm.3, compare = T)
summary(fit_brm.3)
summary(fit_brm.2)
saveRDS(fit_brm.2, "fit_brm.2.RData")
theme_update(text = element_text(family = "sans"))
library(bayesplot) # plot parameters
library(hrbrthemes) # plot themes
theme_update(text = element_text(family = "sans"))
library(tnet) # For weights
library(igraph) # Measure centrality here
library(ggraph)
library(grid)
library(assortnet) # associative indices
library(ggplot2) # Visualization
library(abind) # array
library(brms) # For brm modellibrary(coda)
library(bayesplot) # plot parameters
library(doParallel)
library(hrbrthemes) # plot themes
library(viridis) # plot themes
library(ggpattern) # heatmap hatches
library(patchwork) # plotting together
library(car) # durbinWatsonTest
library(rstan) # To make STAN run faster
library(tidybayes) # get_variables
theme_update(text = element_text(family = "sans"))
# Create mcmc_areas plot
mcmc_plot <- mcmc_areas(
as.array(model),
pars = c("b_Prop_FG", "b_Prop_BG", "b_Prop_SD",
"b_After", "b_During"),
prob = 0.8, # 80% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) + labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 80% intervals"
) + theme_update(text = element_text(family = "sans"))
mcmc_plot + scale_y_discrete(
labels = c(
"b_Prop_FG" = "Fixed Gear Foraging",
"b_Prop_BG" = "Begging/Provisioning",
"b_Prop_SD" = "Scavenging/Depredating",
"b_After" = "After HAB",
"b_During" = "During HAB"
)
)
# Check for model convergence
model <- fit_brm.2
plot(model)
# Only show IDs of HI dolphins
HI_list <- readRDS("HI_list.RData")
HI_list <- HI_list[-4] # Get rid of natural foragers
# Read in ig object
ig <- readRDS("ig.RData")
# ---Plot network---
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
# Initialize a list to store layout information for each graph
layout_list <- list()
# Loop through the list of graphs and save layout information
for (i in 1:length(ig)) {
layout_list[[i]] <- layout_with_fr(ig[[i]])
}
# Set up the plotting layout
layout.matrix <- matrix(c(1:9), nrow = 3, ncol = 3)
layout(mat = layout.matrix)
par(mar = c(0.6, 0.6, 0.6, 0.6))
# Loop through the list of graphs and plot them side by side
for (j in 1:length(HI_list)) {  # Loop through columns first
# Extract layout for this graph
combined_layout <- layout_list[[1]]
counter <- 0
for (i in 1:length(ig)) {  # Loop through rows
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- V(ig[[i]])$name %in% HI_list[[j]][[i]]  # Fixed index here
# Create the plot
plot(ig[[i]],
layout = combined_layout,
edge.width = E(ig[[i]])$weight * 4, # edge thickness
edge.color = adjustcolor("grey", alpha.f = 0.2),
vertex.size = ifelse(labeled_nodes, 10, 3), #sqrt(igraph::strength(ig[[i]], vids = V(ig[[i]]), mode = c("all"), loops = TRUE) * 10), # Changes node size based on an individual's strength (centrality)
vertex.frame.color = NA,
vertex.label.family = "Helvetica",
vertex.label = ifelse(labeled_nodes, V(ig[[i]])$name, NA),
vertex.label.color = "black",
vertex.label.cex = 0.8,
vertex.label.dist = 2,
vertex.frame.width = 0.01,
vertex.color = "black")
# Add the plot with a box around it
box()
}
}
# Set up data
result_df <- readRDS("result_df.RData")
# Plot the density plots for each period
plots_list <- list()
# Plot the density plots for each period
plots_list <- list()
for (i in 1:length(unique(result_df$Period))) {
period_to_plot <- unique(result_df$Period)[i] # each period
filtered_df <- subset(result_df, Period == period_to_plot) # Separate data
mean_nf <- mean(filtered_df$composite_centrality[filtered_df$HI == "NF"], na.rm = TRUE) # Calculate mean for HI=="NF"
plot <- ggplot(filtered_df[filtered_df$HI != "NF", ], aes(x = HI, y = composite_centrality, fill = HI)) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width=0.1, color="black", alpha=0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
geom_hline(yintercept = mean_nf, linetype = "dashed", color = "black", linewidth = 1.5) + # Add horizontal line
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
plots_list[[i]] <- plot
}
# Output plots
plots_list[[1]]
# Plot the density plots for each period
my_colors <- c("#8da0cb", "#a6d854", "#ffd92f")
plots_list <- list()
for (i in 1:length(unique(result_df$Period))) {
period_to_plot <- unique(result_df$Period)[i] # each period
filtered_df <- subset(result_df, Period == period_to_plot) # Separate data
mean_nf <- mean(filtered_df$composite_centrality[filtered_df$HI == "NF"], na.rm = TRUE) # Calculate mean for HI=="NF"
plot <- ggplot(filtered_df[filtered_df$HI != "NF", ], aes(x = HI, y = composite_centrality, fill = HI)) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width=0.1, color="black", alpha=0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
geom_hline(yintercept = mean_nf, linetype = "dashed", color = "black", linewidth = 1.5) + # Add horizontal line
scale_fill_manual(values = my_colors) + # Use custom color palette
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
plots_list[[i]] <- plot
}
# Output plots
plots_list[[1]]
# Plot the density plots for each period
my_colors <- c("#D55E00", "#009E73", "#0072B2")
plots_list <- list()
for (i in 1:length(unique(result_df$Period))) {
period_to_plot <- unique(result_df$Period)[i] # each period
filtered_df <- subset(result_df, Period == period_to_plot) # Separate data
mean_nf <- mean(filtered_df$composite_centrality[filtered_df$HI == "NF"], na.rm = TRUE) # Calculate mean for HI=="NF"
plot <- ggplot(filtered_df[filtered_df$HI != "NF", ], aes(x = HI, y = composite_centrality, fill = HI)) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width=0.1, color="black", alpha=0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
geom_hline(yintercept = mean_nf, linetype = "dashed", color = "black", linewidth = 1.5) + # Add horizontal line
scale_fill_manual(values = my_colors) + # Use custom color palette
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
plots_list[[i]] <- plot
}
# Output plots
plots_list[[1]]
# Plot the density plots for each period
my_colors <- c("#FC4E07", "#009E73", "#00AFBB")
plots_list <- list()
for (i in 1:length(unique(result_df$Period))) {
period_to_plot <- unique(result_df$Period)[i] # each period
filtered_df <- subset(result_df, Period == period_to_plot) # Separate data
mean_nf <- mean(filtered_df$composite_centrality[filtered_df$HI == "NF"], na.rm = TRUE) # Calculate mean for HI=="NF"
plot <- ggplot(filtered_df[filtered_df$HI != "NF", ], aes(x = HI, y = composite_centrality, fill = HI)) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width=0.1, color="black", alpha=0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
geom_hline(yintercept = mean_nf, linetype = "dashed", color = "black", linewidth = 1.5) + # Add horizontal line
scale_fill_manual(values = my_colors) + # Use custom color palette
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
plots_list[[i]] <- plot
}
# Output plots
plots_list[[1]]
plots_list[[2]]
plots_list[[3]]
# Plot the density plots for each HI
library(ggplot2)
library(hrbrthemes)
# Plot the density plots for each HI
# Define a custom color palette
red_shades <- c("#FFC7CE", "#FFA07A", "#E9967A", "#CD5C5C", "#8B4513")
# Plot the density plots for each HI
# Define a custom color palette
red_shades <- c("#E9967A", "#CD5C5C", "#8B4513")
# Define patterns
patterns <- c("crosshatch", "dots", "cross")
# Create an empty list to store the plots
plots_list_HI <- list()
# Loop over each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = composite_centrality, fill = as.factor(Period), pattern = as.factor(Period))) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_violin_pattern(aes(color = as.factor(Period)), pattern = patterns) + # Add pattern to the violins
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_manual(values = red_shades) + # Use manual scale for shades of red
scale_color_manual(values = red_shades) + # Match colors for patterns
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period"),
color = guide_legend(title = "Period")) # Add legend for Period and pattern
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]]
install.packages("ggpattern")
install.packages("ggpattern")
install.packages("ggpattern")
# Plot the density plots for each HI
library(ggpattern)
# Plot the density plots for each HI
# Define a list to store plots
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = composite_centrality, fill = as.factor(Period))) +
geom_violin_pattern(trim = FALSE, alpha = 0.4, pattern_fill = "grey50") + # Add pattern to the violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_manual(values = red_shades) + # Use manual scale for shades of red
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) # Add legend for Period
plots_list_HI[[i]] <- plot
}
library(ggplot2) # Visualization
library(hrbrthemes) # plot themes
# Plot the density plots for each HI
# Define a list to store plots
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = composite_centrality, fill = as.factor(Period))) +
geom_violin_pattern(trim = FALSE, alpha = 0.4, pattern_fill = "grey50") + # Add pattern to the violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_manual(values = red_shades) + # Use manual scale for shades of red
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) # Add legend for Period
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]]
# Plot the density plots for each HI
## Define colors
grey_shades <- c("#DDDDDD", "#BBBBBB", "#999999")
## Define pattern types
pattern_types <- c("stripe", "crosshatch", "checkerboard")
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = composite_centrality, fill = as.factor(Period))) +
geom_violin_pattern(trim = FALSE, alpha = 0.4,
pattern_type = pattern_types[i %% length(pattern_types) + 1], # Add pattern to the violin plot
pattern_fill = "black") + # Add pattern to the violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_manual(values = grey_shades) + # Use manual scale for shades of grey
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) # Add legend for Period
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]]
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = composite_centrality, fill = as.factor(Period))) +
geom_violin_pattern(trim = FALSE, alpha = 0.4,
pattern_type = pattern_types, # Add pattern to the violin plot
pattern_fill = "black") + # Add pattern to the violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_manual(values = grey_shades) + # Use manual scale for shades of grey
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) # Add legend for Period
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]]
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = composite_centrality, fill = as.factor(Period))) +
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_manual(values = grey_shades) + # Use manual scale for shades of grey
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) # Add legend for Period
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]]
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = composite_centrality, fill = as.factor(Period))) +
geom_violin_pattern(trim = FALSE, alpha = 0.4) + # Add pattern to the violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_manual(values = grey_shades) + # Use manual scale for shades of grey
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) # Add legend for Period
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]]
# Plot the density plots for each HI
## Define colors
grey_shades <- c("#DDDDDD", "#BBBBBB", "#999999")
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = composite_centrality, fill = as.factor(Period))) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_manual(values = grey_shades) + # Use manual scale for shades of red
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) # Add legend for Period
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]]
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = composite_centrality, fill = as.factor(Period))) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_grey(start = 0, end = .9) +
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) # Add legend for Period
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]]
plots_list_HI[[2]]
plots_list_HI[[3]]
