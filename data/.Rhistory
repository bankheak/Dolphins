for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.4
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.2
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size")
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 1)))
(max(N_small) + 50)
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
N_small
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 50)))
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_med) + 1)))
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_large) + 1)))
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size")
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size")
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size")
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(0, 0.2)
abline(0, 0.3, lty=2)
abline(0, 0.4, lty=3)
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N_20, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
N_30[1] <- N0
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N_30, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
N_40[1] <- N0
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N_40, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
gc()
# Set working directory here
setwd("../data")
gc()
# Set working directory here
setwd("../data")
# Only show IDs of HI dolphins
HI_list <- readRDS("HI_list.RData")
HI_list <- HI_list[-4] # Get rid of natural foragers
# Read in ig object
ig <- readRDS("ig.RData")
# Set up data
result_df <- readRDS("result_df.RData")
# Plot the density plots for each period
my_colors <- c("#FC4E07", "#009E73", "#00AFBB")
plots_list <- list()
for (i in 1:length(unique(result_df$Period))) {
period_to_plot <- unique(result_df$Period)[i] # each period
filtered_df <- subset(result_df, Period == period_to_plot) # Separate data
mean_nf <- mean(filtered_df$composite_centrality[filtered_df$HI == "NF"], na.rm = TRUE) # Calculate mean for HI=="NF"
plot <- ggplot(filtered_df[filtered_df$HI != "NF", ], aes(x = HI, y = composite_centrality, fill = HI)) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width=0.1, color="black", alpha=0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
geom_hline(yintercept = mean_nf, linetype = "dashed", color = "black", linewidth = 1.5) + # Add horizontal line
scale_fill_manual(values = my_colors) + # Use custom color palette
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
plots_list[[i]] <- plot
}
library(ggplot2) # Visualization
plots_list <- list()
for (i in 1:length(unique(result_df$Period))) {
period_to_plot <- unique(result_df$Period)[i] # each period
filtered_df <- subset(result_df, Period == period_to_plot) # Separate data
mean_nf <- mean(filtered_df$composite_centrality[filtered_df$HI == "NF"], na.rm = TRUE) # Calculate mean for HI=="NF"
plot <- ggplot(filtered_df[filtered_df$HI != "NF", ], aes(x = HI, y = composite_centrality, fill = HI)) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width=0.1, color="black", alpha=0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
geom_hline(yintercept = mean_nf, linetype = "dashed", color = "black", linewidth = 1.5) + # Add horizontal line
scale_fill_manual(values = my_colors) + # Use custom color palette
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
plots_list[[i]] <- plot
}
View(HI_list)
View(result_df)
plots_list <- list()
for (i in 1:length(unique(result_df$Period))) {
period_to_plot <- unique(result_df$Period)[i] # each period
filtered_df <- subset(result_df, Period == period_to_plot) # Separate data
mean_nf <- mean(filtered_df$Strength[filtered_df$HI == "NF"], na.rm = TRUE) # Calculate mean for HI=="NF"
plot <- ggplot(filtered_df[filtered_df$HI != "NF", ], aes(x = HI, y = Strength, fill = HI)) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width=0.1, color="black", alpha=0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
geom_hline(yintercept = mean_nf, linetype = "dashed", color = "black", linewidth = 1.5) + # Add horizontal line
scale_fill_manual(values = my_colors) + # Use custom color palette
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
plots_list[[i]] <- plot
}
library(hrbrthemes) # plot themes
library(viridis) # plot themes
plots_list <- list()
for (i in 1:length(unique(result_df$Period))) {
period_to_plot <- unique(result_df$Period)[i] # each period
filtered_df <- subset(result_df, Period == period_to_plot) # Separate data
mean_nf <- mean(filtered_df$Strength[filtered_df$HI == "NF"], na.rm = TRUE) # Calculate mean for HI=="NF"
plot <- ggplot(filtered_df[filtered_df$HI != "NF", ], aes(x = HI, y = Strength, fill = HI)) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width=0.1, color="black", alpha=0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
geom_hline(yintercept = mean_nf, linetype = "dashed", color = "black", linewidth = 1.5) + # Add horizontal line
scale_fill_manual(values = my_colors) + # Use custom color palette
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank())
plots_list[[i]] <- plot
}
# Output plots
plots_list[[1]]
plots_list[[2]] # During
plots_list[[3]] # After
# Plot the density plots for each HI
## Define colors
grey_shades <- c("#DDDDDD", "#BBBBBB", "#999999")
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
plot <- ggplot(filtered_df, aes(x = Period, y = Strength, fill = as.factor(Period))) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_grey(start = 0, end = .9) +
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) + # Add legend for Period
coord_flip()
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]] # BG
plots_list_HI[[2]] # FG
plots_list_HI[[3]] # SD
plots_list_HI <- list()
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
# Reorder the levels of the Period factor variable
filtered_df$Period <- factor(filtered_df$Period, levels = rev(levels(filtered_df$Period)))
# Plot the graphs
plot <- ggplot(filtered_df, aes(x = Period, y = Strength, fill = as.factor(Period))) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_grey(start = 0, end = .9) +
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) + # Add legend for Period
coord_flip()
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]] # BG
# Plot the density plots for each HI
## Define colors
grey_shades <- c("#DDDDDD", "#BBBBBB", "#999999")
# Plot the density plots for each HI
## Define colors
grey_shades <- c("#DDDDDD", "#BBBBBB", "#999999")
# Plot the density plots for each HI
## Define colors
grey_shades <- c("#DDDDDD", "#BBBBBB", "#999999")
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
# Reorder the levels of the Period factor variable
filtered_df$Period <- factor(filtered_df$Period, levels = rev(levels(filtered_df$Period)))
# Plot the graphs
plot <- ggplot(filtered_df, aes(x = Period, y = Strength, fill = as.factor(Period))) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_grey(start = 0, end = .9) +
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) + # Add legend for Period
coord_flip()
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]] # BG
i=1
HI_to_plot <- unique(result_df$HI)[i] # each HI category
HI_to_plot
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
filtered_df
HI_to_plot
# Reorder the levels of the Period factor variable
filtered_df$Period <- factor(filtered_df$Period, levels = rev(levels(filtered_df$Period)))
filtered_df
?reorder()
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
# Plot the graphs
plot <- ggplot(filtered_df, aes(x = reorder(Period, Strength), y = Strength, fill = as.factor(Period))) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_grey(start = 0, end = .9) +
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) + # Add legend for Period
coord_flip()
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]] # BG
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
# Plot the graphs
plot <- ggplot(filtered_df, aes(x = reorder(Period, -Strength), y = Strength, fill = as.factor(Period))) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_grey(start = 0, end = .9) +
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) + # Add legend for Period
coord_flip()
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]] # BG
filtered_df
i=1
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
# Reorder the data
filtered_df$Period <- factor(filtered_df$Period,
levels = c('3-After_HAB', '2-During_HAB', '1-Before_HAB'),
ordered = TRUE)
filtered_df
filtered_df$Period
plots_list_HI <- list()
# Loop through each HI category
for (i in 1:(length(unique(result_df$HI))-1)) {
HI_to_plot <- unique(result_df$HI)[i] # each HI category
filtered_df <- subset(result_df, HI == HI_to_plot) # Separate data
# Reorder the data
filtered_df$Period <- factor(filtered_df$Period,
levels = c('3-After_HAB', '2-During_HAB', '1-Before_HAB'),
ordered = TRUE)
# Plot the graphs
plot <- ggplot(filtered_df, aes(x = Period, y = Strength, fill = as.factor(Period))) +
geom_violin(trim = FALSE, alpha = 0.4) + # Create violin plot
geom_boxplot(width = 0.1, color = "black", alpha = 0.2) +
geom_jitter(width = 0.1, alpha = 0.6) + # Add jittered points for visibility
scale_fill_grey(start = 0, end = .9) +
theme_ipsum() +
theme(axis.text.y = element_blank(),
axis.title.y = element_blank()) +
guides(fill = guide_legend(title = "Period")) + # Add legend for Period
coord_flip()
plots_list_HI[[i]] <- plot
}
# Output plots
plots_list_HI[[1]] # BG
plots_list_HI[[2]] # FG
plots_list_HI[[3]] # SD
# Set working directory here
setwd("../data")
list_years <- readRDS("list_years.RData") # (1995-2000)/(2001-2006)/(2007-2012)
nxn <- readRDS("nxn.RData") # association matrix of list_years
# Read in ig object
ig <- readRDS("ig.RData")
# Only show IDs of HI dolphins
HI_list <- readRDS("HI_list.RData")
HI_list <- HI_list[-4] # Get rid of natural foragers
HI_IDs <- unique(as.vector(unlist(HI_list))) # Put them all together
#----Modularity---
# igraph format with weight
el_years <- readRDS("el_years.RData")
library(doParallel) # Faster computing
n.cores <- detectCores()
registerDoParallel(n.cores)
dolphin_ig <- list()
for (j in seq_along(list_years)) {
dolphin_ig[[j]] <- graph_from_adjacency_matrix(as.matrix(nxn[[j]]),
mode="undirected",
weighted=TRUE, diag=FALSE)
}
library(igraph) # graphing networks
dolphin_ig <- list()
for (j in seq_along(list_years)) {
dolphin_ig[[j]] <- graph_from_adjacency_matrix(as.matrix(nxn[[j]]),
mode="undirected",
weighted=TRUE, diag=FALSE)
}
# Create an unweighted network
dolp_ig <- list()
for (l in seq_along(list_years)) {
dolp_ig[[l]] <- graph_from_edgelist(el_years[[l]][,1:2])
# Add the edge weights to this network
E(dolp_ig[[l]])$weight <- as.numeric(el_years[[l]][,3])
# Create undirected network
dolp_ig[[l]] <- as.undirected(dolp_ig[[l]])
}
### End parallel processing
stopImplicitCluster()
newman <- readRDS("newman.RData")
# Generate a vector of colors based on the number of unique memberships
for (i in seq_along(dolp_ig)) {
# Generate a vector of colors based on the number of unique memberships
col <- rainbow(max(newman[[i]]$membership))
# Initialize the color attribute with NA
V(dolp_ig[[i]])$color <- NA
# Loop through each membership value and assign colors to corresponding vertices
for (j in 1:max(newman[[i]]$membership)){
V(dolp_ig[[i]])$color[newman[[i]]$membership == j] <- rep(col[j], sum(newman[[i]]$membership == j))
}
}
# Read in homerange for individuals
kernel <- readRDS("kernel.RData")
# Create a for loop to store each period's average coordinates
centroid_list <- list()
for (k in 1:3) {
# Create an empty data frame to store centroid coordinates
centroid_coords <- data.frame(dolphin = character(),
avg_lat = numeric(),
avg_lon = numeric())
# Take out each period's home range
home_range <- kernel[[k]]
# Loop through each dolphin's home range
for (i in 1:length(home_range)) {
# Extract the spatial points representing the home range
points <- coordinates(home_range[[i]])
# Calculate the average latitude and longitude
avg_lat <- mean(points[, 2])
avg_lon <- mean(points[, 1])
# Add the centroid coordinates to the data frame
centroid_coords <- rbind(centroid_coords, data.frame(dolphin = names(home_range)[i],
avg_lat = avg_lat,
avg_lon = avg_lon))
}
centroid_list[[k]] <- centroid_coords
}
library(sf) # Convert degrees to meters
library(sp) # Creates a SpatialPointsDataFrame by defining the coordinates
library(adehabitatHR)
# Create a for loop to store each period's average coordinates
centroid_list <- list()
for (k in 1:3) {
# Create an empty data frame to store centroid coordinates
centroid_coords <- data.frame(dolphin = character(),
avg_lat = numeric(),
avg_lon = numeric())
# Take out each period's home range
home_range <- kernel[[k]]
# Loop through each dolphin's home range
for (i in 1:length(home_range)) {
# Extract the spatial points representing the home range
points <- coordinates(home_range[[i]])
# Calculate the average latitude and longitude
avg_lat <- mean(points[, 2])
avg_lon <- mean(points[, 1])
# Add the centroid coordinates to the data frame
centroid_coords <- rbind(centroid_coords, data.frame(dolphin = names(home_range)[i],
avg_lat = avg_lat,
avg_lon = avg_lon))
}
centroid_list[[k]] <- centroid_coords
}
# Order data
order_rows <- rownames(nxn[[1]])
centroid_list <- lapply(centroid_list, function(df) {
df <- df[df$dolphin %in% order_rows, , drop = FALSE]  # Subsetting rows based on order_rows
df <- df[match(order_rows, df$dolphin), ]  # Reorder rows based on order_rows
return(df)  # Returning the modified data frame
})
# Define a function to convert UTM coordinates to longitude and latitude
utm_to_lonlat <- function(x, y, zone = 17, northern = TRUE) {
proj <- sprintf("+proj=utm +zone=%d %s", zone, ifelse(northern, "+north", "+south"))
xy <- data.frame(x = x, y = y)
xy <- SpatialPoints(xy, proj4string = CRS(proj))
xy <- spTransform(xy, CRS("+proj=longlat +datum=WGS84"))
return(coordinates(xy))
}
# Convert UTM coordinates to longitude and latitude
centroid_list <- lapply(centroid_list, function(df) {
lonlat <- utm_to_lonlat(df$avg_lon, df$avg_lat)
centroid_list <- data.frame(ID = df$dolphin,
X = lonlat[,1],
Y = lonlat[,2])
return(centroid_list)})
labeled_nodes <- list()
i=1
# Adjust the layout using home range coordinates
layout_coords <- as.matrix(centroid_list[[i]][, c("X", "Y")])
adjusted_layout <- layout_coords[order(V(ig[[i]])$name), ]
if(!require(ggnet)){install.packages('ggnet'); library(ggnet)}
install.packages("ggnet")
gc()
