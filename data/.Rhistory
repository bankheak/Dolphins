segment.alpha = 0.2, # transparency of edges
segment.size = get.edge.attribute(net_i, "weight"), # edge thickness
label.nodes = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.size = 0.8) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
scale_fill_brewer(palette = "Set1") +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
}
# Plot one at a time
plot_1 <- plot_list[[1]]
plot_1
## Read in nxn
nxn <- readRDS("nxn.RData")
# Read in ig object
net <- readRDS("net.RData")
ig <- readRDS("ig.RData")
# Only show IDs of HI dolphins
HI_list <- readRDS("HI_list.RData")
HI_list <- HI_list[-4] # Get rid of natural foragers
HI_IDs <- unique(as.vector(unlist(HI_list))) # Put them all together
#----Modularity---
# igraph format with weight
el_years <- readRDS("el_years.RData")
dolp_ig <- readRDS("dolp_ig.RData")
newman <- readRDS("newman.RData")
# Generate a vector of colors based on the number of unique memberships
for (i in seq_along(dolp_ig)) {
# Generate a vector of colors based on the number of unique memberships
col <- viridis(min(max(newman[[i]]$membership), length(unique(newman[[i]]$membership))))
# Initialize the color attribute with NA
V(dolp_ig[[i]])$color <- NA
# Loop through each membership value and assign colors to corresponding vertices
for (j in 1:max(newman[[i]]$membership)){
V(dolp_ig[[i]])$color[newman[[i]]$membership == j] <- rep(col[j], sum(newman[[i]]$membership == j))
}
}
centroid_list <- readRDS("centroid_list.RData")
# Define a function to convert UTM coordinates to longitude and latitude
utm_to_lonlat <- function(x, y, zone = 17, northern = TRUE) {
proj <- sprintf("+proj=utm +zone=%d %s", zone, ifelse(northern, "+north", "+south"))
xy <- data.frame(x = x, y = y)
xy <- SpatialPoints(xy, proj4string = CRS(proj))
xy <- spTransform(xy, CRS("+proj=longlat +datum=WGS84"))
return(coordinates(xy))
}
# Convert UTM coordinates to longitude and latitude
centroid_list <- lapply(centroid_list, function(df) {
lonlat <- utm_to_lonlat(df$Longitude, df$Latitude)
centroid_list <- data.frame(ID = df$ID,
X = lonlat[,1],
Y = lonlat[,2])
return(centroid_list)})
# ---Plot network---
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
labeled_nodes <- list()
plot_list <- list()
register_google(key = "AIzaSyAgFfxIJmkL8LAWE7kHCqSqKBQDvqa9umI")
for (i in 1:length(ig)) {  # Loop through periods
# Load in igraph
require(igraph)
# Adjust the layout using home range coordinates
layout_coords <- as.matrix(centroid_list[[i]][, c("X", "Y")])
adjusted_layout <- layout_coords[order(V(ig[[i]])$name), ]
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Get map of Sarasota, Florida
sarasota_map <- basemap(limits = c(-82.8, -82.3, 27, 27.6))
# add geographic coordinates
net_i <- net[[i]]
net_i %v% "lat" <- layout_coords[,"Y"]
net_i %v% "lon" <- layout_coords[,"X"]
x <- net_i %v% "lon"
y <- net_i %v% "lat"
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Unrequire igraph
#detach("package:igraph", unload=TRUE)
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Graph network
plot <- ggnetworkmap(
sarasota_map, # Load in map
net_i, # Load in network
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
alpha = 0.8, # transparency of nodes
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
segment.alpha = 0.2, # transparency of edges
segment.size = get.edge.attribute(net_i, "weight"), # edge thickness
label.nodes = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.size = 0.8) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
scale_fill_brewer(palette = "Set1") +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
}
florida_map <- basemap(limits = c(-87.6349, -79.9743, 24.3963, 31.0006)) +
theme(axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank())
for (i in 1:length(ig)) {  # Loop through periods
# Load in igraph
require(igraph)
# Adjust the layout using home range coordinates
layout_coords <- as.matrix(centroid_list[[i]][, c("X", "Y")])
adjusted_layout <- layout_coords[order(V(ig[[i]])$name), ]
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Get map of Sarasota, Florida
sarasota_map <- basemap(limits = c(-82.8, -82.3, 27, 27.6))
# add geographic coordinates
net_i <- net[[i]]
net_i %v% "lat" <- layout_coords[,"Y"]
net_i %v% "lon" <- layout_coords[,"X"]
x <- net_i %v% "lon"
y <- net_i %v% "lat"
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Unrequire igraph
#detach("package:igraph", unload=TRUE)
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Graph network
plot <- ggnetworkmap(
sarasota_map, # Load in map
net_i, # Load in network
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
alpha = 0.8, # transparency of nodes
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
segment.alpha = 0.2, # transparency of edges
segment.size = get.edge.attribute(net_i, "weight"), # edge thickness
label.nodes = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.size = 0.8) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
scale_fill_brewer(palette = "Set1") +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
}
# Plot one at a time
plot_1 <- plot_list[[1]]
plot_1
# Create non-mapped graph
labeled_nodes <- list()
plot_list <- list()
for (i in 1:length(ig)) {  # Loop through periods
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Make net_i
net_i <- ig[[i]]
net_i <- simplify(net_i)
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
# Update vertex attributes
V(net_i)$grp <- as.character(node_color_numbers)
create_group_layout <- function(graph, node_groups, layout_func = layout_with_fr, group_spacing = 5) {
# Get unique groups
unique_groups <- unique(node_groups)
# Initialize an empty layout
layout <- matrix(0, nrow = vcount(graph), ncol = 2)
# Apply the layout function to each group individually
for (i in seq_along(unique_groups)) {
group_idx <- which(node_groups == unique_groups[i])
subgraph <- induced_subgraph(graph, group_idx)
sub_layout <- layout_func(subgraph)
# Normalize sub_layout to avoid large coordinate ranges
sub_layout <- sub_layout / max(abs(sub_layout))
# Offset sub_layout
offset_x <- (i - 1) * group_spacing
offset_y <- (i - 1) * group_spacing
layout[group_idx, ] <- sub_layout + c(offset_x, offset_y)
}
return(layout)
}
# Generate a layout based on the node groups
bb <- create_group_layout(net_i, V(net_i)$grp)
# Create the plot
plot <- ggraph(net_i, layout = "manual", x = bb[, 1], y = bb[, 2]) +
geom_edge_link0(aes(color = "grey80", width = E(net_i)$weight), alpha = 0.08) +
geom_node_point(aes(fill = grp, size = ifelse(labeled_nodes[[i]], 1.5, 0.5)), shape = 21) +
geom_text(aes(x = bb[, 1], y = bb[, 2], label = ifelse(labeled_nodes[[i]], V(net_i)$name, "")), color = "black", size = 2, vjust = 1.5) +
geom_mark_hull(aes(x = bb[, 1], y = bb[, 2], group = grp, fill = grp),
concavity = 4,
expand = unit(2, "mm"),
alpha = 0.25) +
scale_fill_brewer(palette = "Set1") +
scale_edge_color_manual(values = c(rgb(0, 0, 0, 0.1), rgb(0, 0, 0, 0.3))) +
theme_graph() +
theme(legend.position = "none")
plot_list[[i]] <- plot
}
plot_list[[1]]
# Create an unweighted network
install.packages('igraph', version = '1.6.0')
# ---Plot network---
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
labeled_nodes <- list()
plot_list <- list()
for (i in 1:length(ig)) {  # Loop through periods
# Load in igraph
require(igraph)
# Adjust the layout using home range coordinates
layout_coords <- as.matrix(centroid_list[[i]][, c("X", "Y")])
adjusted_layout <- layout_coords[order(V(ig[[i]])$name), ]
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Get map of Sarasota, Florida
sarasota_map <- basemap(limits = c(-82.8, -82.3, 27, 27.6))
# add geographic coordinates
net_i <- net[[i]]
net_i %v% "lat" <- layout_coords[,"Y"]
net_i %v% "lon" <- layout_coords[,"X"]
x <- net_i %v% "lon"
y <- net_i %v% "lat"
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Unrequire igraph
#detach("package:igraph", unload=TRUE)
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Graph network
plot <- ggnetworkmap(
sarasota_map, # Load in map
net_i, # Load in network
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
alpha = 0.8, # transparency of nodes
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
segment.alpha = 0.2, # transparency of edges
segment.size = get.edge.attribute(net_i, "weight"), # edge thickness
label.nodes = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.size = 0.8) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
scale_fill_brewer(palette = "Set1") +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
}
i=1
# Load in igraph
require(igraph)
if(!require(igraph)){install.packages('igraph', version = '1.6.0'); library(igraph)} # graph_from_adjacency_matrix version = '1.6.0'
if(!require(kinship2)){install.packages('kinship2'); library(kinship2)} # genetic relatedness
if(!require(adehabitatHR)){install.packages('adehabitatHR'); library(adehabitatHR)} # Caluculate MCPs and Kernel density
## Network
if(!require(ggalt)){install.packages('ggalt'); library(ggalt)}
if(!require(network)){install.packages('network'); library(network)} # For assigning coordinates to nodes %v%
if(!require(ggmap)){install.packages('ggmap'); library(ggmap)} # register API key version = '3.0.0'
if(!require(graphlayouts)){install.packages('graphlayouts'); library(graphlayouts)}
if(!require(ggforce)){install.packages('ggforce'); library(ggforce)} # mapping clusters geom_mark_hull
if(!require(ggraph)){install.packages('ggraph'); library(ggraph)} # For network plotting on map
if(!require(tnet)){install.packages('tnet'); library(tnet)} # For weights
if(!require(asnipe)){install.packages('asnipe'); library(asnipe)} # get_group_by_individual
if(!require(assortnet)){install.packages('assortnet'); library(assortnet)} # associative indices
## Mapping
if(!require(statnet)){install.packages('statnet'); library(statnet)}
if(!require(viridis)){install.packages('viridis'); library(viridis)}
if(!require(ggnetwork)){install.packages('ggnetwork'); library(ggnetwork)} # Get cluster coords
if(!require(ggforce)){install.packages('ggforce'); library(ggforce)} # for drawing lines around social clusters
if(!require(ggOceanMaps)){install.packages('ggOceanMaps'); library(ggOceanMaps)} # To map florida
if(!require(intergraph)){install.packages('intergraph'); library(intergraph)} # To use igraph network in ggnet
if(!require(sna)){install.packages('sna'); library(sna)} # For network
if(!require(GGally)){install.packages('GGally'); library(GGally)} # For mapping networks in ggplot version = '2.2.1'
if(!require(ggplot2)){install.packages('ggplot2'); library(ggplot2)}
if(!require(sf)){install.packages('sf'); library(sf)} # Convert degrees to meters
if(!require(sp)){install.packages('sp'); library(sp)} # Convert degrees to meters
## Bayesian
if(!require(abind)){install.packages('abind'); library(abind)} # array
if(!require(brms)){install.packages('brms'); library(brms)} # For brm model
if(!require(coda)){install.packages('coda'); library(coda)}
if(!require(bayesplot)){install.packages('bayesplot'); library(bayesplot)} # plot parameters in mcmc_area
if(!require(magrittr)){install.packages('magrittr'); library(magrittr)} # For STAN
if(!require(dplyr)){install.packages('dplyr'); library(dplyr)}  # for organizing code
if(!require(rstan)){install.packages('rstan'); library(rstan)} # To make STAN run faster
if(!require(ggrepel)){install.packages('ggrepel'); library(ggrepel)} # for function labs
if(!require(RColorBrewer)){install.packages('RColorBrewer'); library(RColorBrewer)}
if(!require(gganimate)){install.packages('gganimate'); library(gganimate)}
if(!require(posterior)){install.packages('posterior'); library(posterior)} # Find the posterior sample names
if(!require(distributional)){install.packages('distributional'); library(distributional)}
if(!require(doParallel)){install.packages('doParallel'); library(doParallel)} # Faster computing
# Load in igraph
require(igraph)
# Adjust the layout using home range coordinates
layout_coords <- as.matrix(centroid_list[[i]][, c("X", "Y")])
adjusted_layout <- layout_coords[order(V(ig[[i]])$name), ]
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Get map of Sarasota, Florida
sarasota_map <- basemap(limits = c(-82.8, -82.3, 27, 27.6))
sarasota_map
# add geographic coordinates
net_i <- net[[i]]
net_i %v% "lat" <- layout_coords[,"Y"]
net_i %v% "lon" <- layout_coords[,"X"]
x <- net_i %v% "lon"
y <- net_i %v% "lat"
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Graph network
plot <- ggnetworkmap(
sarasota_map, # Load in map
net_i, # Load in network
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
alpha = 0.8, # transparency of nodes
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
segment.alpha = 0.2, # transparency of edges
segment.size = get.edge.attribute(net_i, "weight"), # edge thickness
label.nodes = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.size = 0.8) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
scale_fill_brewer(palette = "Set1") +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
plot_list[[i]]
?basemap
# Get map of Sarasota, Florida
sarasota_map <- basemap(limits = c(-82.8, -82.3, 27, 27.6), land.col = "lightgray")
sarasota_map
# Graph network
plot <- ggnetworkmap(
sarasota_map, # Load in map
net_i, # Load in network
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
alpha = 0.8, # transparency of nodes
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
segment.alpha = 0.2, # transparency of edges
segment.size = get.edge.attribute(net_i, "weight"), # edge thickness
label.nodes = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.size = 0.8) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
scale_fill_brewer(palette = "Set1") +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
plot_list[[i]]
i=2
# ---Plot network---
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
labeled_nodes <- list()
plot_list <- list()
# Adjust the layout using home range coordinates
layout_coords <- as.matrix(centroid_list[[i]][, c("X", "Y")])
adjusted_layout <- layout_coords[order(V(ig[[i]])$name), ]
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Get map of Sarasota, Florida
sarasota_map <- basemap(limits = c(-82.8, -82.3, 27, 27.6), land.col = "lightgray")
# add geographic coordinates
net_i <- net[[i]]
net_i %v% "lat" <- layout_coords[,"Y"]
net_i %v% "lon" <- layout_coords[,"X"]
x <- net_i %v% "lon"
y <- net_i %v% "lat"
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Graph network
plot <- ggnetworkmap(
sarasota_map, # Load in map
net_i, # Load in network
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
alpha = 0.8, # transparency of nodes
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
segment.alpha = 0.2, # transparency of edges
segment.size = get.edge.attribute(net_i, "weight"), # edge thickness
label.nodes = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.size = 0.8) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
scale_fill_brewer(palette = "Set1") +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
plot_list[[i]]
i=3
# Adjust the layout using home range coordinates
layout_coords <- as.matrix(centroid_list[[i]][, c("X", "Y")])
adjusted_layout <- layout_coords[order(V(ig[[i]])$name), ]
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Get map of Sarasota, Florida
sarasota_map <- basemap(limits = c(-82.8, -82.3, 27, 27.6), land.col = "lightgray")
# add geographic coordinates
net_i <- net[[i]]
net_i %v% "lat" <- layout_coords[,"Y"]
net_i %v% "lon" <- layout_coords[,"X"]
x <- net_i %v% "lon"
y <- net_i %v% "lat"
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Graph network
plot <- ggnetworkmap(
sarasota_map, # Load in map
net_i, # Load in network
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
alpha = 0.8, # transparency of nodes
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
segment.alpha = 0.2, # transparency of edges
segment.size = get.edge.attribute(net_i, "weight"), # edge thickness
label.nodes = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.size = 0.8) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
scale_fill_brewer(palette = "Set1") +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
plot_list[[i]]
i=3
