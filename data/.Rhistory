image(kernel.lscv)
plot(kernel.lscv)
plotLSCV(kernel.lscv)
kernel.lscv
# Get the names or IDs of the individuals that are of concern
selected_individuals <- c("F101", "F191", "F192", "FB15", "FB35", "FB41", "FB93")
# Plot the LSCV for the selected individuals
plotLSCV(kernel.lscv, groups = selected_individuals)
# Get the LSCV values for the selected individuals
lscv_data <- lscv(kernel.lscv)
library(adehabitatHR) # Kernel density
# Get the LSCV values for the selected individuals
lscv_data <- lscv(kernel.lscv)
# Get the bandwidth values used in the LSCV analysis
bandwidth_values <- kernel.lscv$h
# Calculate the LSCV values for each individual
lscv_values <- LSCV.SpatialGrid(kernel.lscv)
lscv_values
# Repeat code above to calculate appropriate bandwidth for IDs of concern
concern.sp <- coord_data[, c("id", "y", "x")]
concern.sp <- subset(concern.sp, subset=c(concern.sp$id = selected_individuals)) # Only include selected ids
concern.sp <- subset(concern.sp, subset=c(concern.sp$id == selected_individuals)) # Only include selected ids
concern.sp <- subset(concern.sp, id %in% selected_individuals) # Only include selected ids
View(concern.sp)
concern_sf <- st_as_sf(concern.sp, coords = c("x", "y"), crs = 4326)
concern.sf <- st_transform(concern_sf, crs = paste0("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
concern.sp$x <- st_coordinates(concern.sf)[, 1]
concern.sp$y <- st_coordinates(concern.sf)[, 2]
View(concern.sp)
coordinates(concern.sp) <- c("x", "y")
proj4string(concern.sp) <- CRS( "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs" )
# Now recalculate kernel estimates for each id
kernel.con <- kernelUD(concern.sp, h = "LSCV")
# Test one year at a time
coord_data <- coord_years[[1]]
# Eliminate IDs with less than 5 locations
coord_data <- subset(coord_data, subset=c(coord_data$id != "None"))
coord_data <- coord_data[!is.na(coord_data$x) & !is.na(coord_data$y),]
# Test one year at a time
coord_data <- coord_years[[1]]
# Eliminate IDs with less than 5 locations
coord_data <- subset(coord_data, subset=c(coord_data$id != "None"))
coord_data <- coord_data[!is.na(coord_data$x) & !is.na(coord_data$y),]
ID <- unique(coord_data$id)
obs_vect <- NULL
for (i in 1:length(ID)) {
obs_vect[i]<- sum(coord_data$id == ID[i])
}
sub <- data.frame(ID, obs_vect)
sub <- subset(sub, subset=c(sub$obs_vect > 10))
coord_data <- subset(coord_data, coord_data$id %in% c(sub$ID))
# Only include three columns (id, x, and y coordinates) for making MCP's
dolph.sp <- coord_data[, c("id", "y", "x")]
dolph.sp <- dolph.sp[!is.na(dolph.sp$x) & !is.na(dolph.sp$y),]
# Create a simple feature data frame (sf)
coord_data_sf <- st_as_sf(dolph.sp, coords = c("x", "y"), crs = 4326)
# UTM zone for study area
dolph.sf <- st_transform(coord_data_sf, crs = paste0("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Extract coordinates (latitude and longitude) and create new columns
dolph.sp$x <- st_coordinates(dolph.sf)[, 1]
dolph.sp$y <- st_coordinates(dolph.sf)[, 2]
# Remove two rows with NA's
dolph.sp <- dolph.sp[!is.na(dolph.sp$x) & !is.na(dolph.sp$y),]
coordinates(dolph.sp) <- c("x", "y")
# Set the initial CRS for data to WGS84 (latitude and longitude)
proj4string(dolph.sp) <- CRS( "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs" )
# Create kernel estimates for each id
kernel.lscv <- kernelUD(dolph.sp, h = "LSCV")  # LSCV = least squares cross validation
kernel.lscv
# Get the names or IDs of the individuals that are of concern
selected_individuals <- c("F101", "F191", "F192", "FB15", "FB35", "FB41", "FB93")
# Repeat code above to calculate appropriate bandwidth for IDs of concern
concern.sp <- coord_data[, c("id", "y", "x")]
concern.sp <- subset(concern.sp, id %in% selected_individuals) # Only include selected ids
concern_sf <- st_as_sf(concern.sp, coords = c("x", "y"), crs = 4326)
concern.sf <- st_transform(concern_sf, crs = paste0("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
concern.sp$x <- st_coordinates(concern.sf)[, 1]
concern.sp$y <- st_coordinates(concern.sf)[, 2]
coordinates(concern.sp) <- c("x", "y")
View(concern.sp)
concern.sp <- concern.sp[!is.na(concern.sp$x) & !is.na(concern.sp$y),]
coordinates(concern.sp) <- c("x", "y")
proj4string(concern.sp) <- CRS( "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs" )
# Now recalculate kernel estimates for each id
kernel.con <- kernelUD(concern.sp, h = "LSCV")
kernel.con
image(kernel.con)
plotLSCV(kernel.con)
kernel.lscv <- kernelUD(dolph.sp, h = 1000)
# 95% of estimated distribution
dolph.kernel.poly <- getverticeshr(kernel.lscv, percent = 95)
print(dolph.kernel.poly)  # returns the area of each polygon
plot(dolph.kernel.poly, col = dolph.kernel.poly@data$id)
print(dolph.kernel.poly)  # returns the area of each polygon
class(dolph.kernel.poly)
# # Initialize an empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly)
n_individuals
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = list(individual_ids, individual_ids))
View(dolph.kernel.poly)
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = dolph.kernel.poly@data$id)
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = list(dolph.kernel.poly@data$id, dolph.kernel.poly@data$id))
HRO_matrix
HRO <- function(kernel.poly) {
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(kernel.poly)
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = list(kernel.poly@data$id, kernel.poly@data$id))
# For loop to calculate HRO for each pair
for (i in 1:n_individuals) {
for (j in (i+1):n_individuals) {
# Get the home range polygons for individuals i and j
poly_i <- kernel.poly[[i]]
poly_j <- kernel.poly[[j]]
# Calculate the overlap area between the home ranges (Rij)
O_area <- area(gIntersection(poly_i, poly_j))
# Calculate the home range area for individuals i and j (Ri and Rj)
home_range_area_i <- area(poly_i)
home_range_area_j <- area(poly_j)
# Calculate HRO using the formula: HRO = (Rij/Ri) * (Rij/Rj)
HRO_index <- (O_area / home_range_area_i) * (O_area / home_range_area_j)
# Store the HRO value in the matrix
HRO_matrix[individual_ids[i], individual_ids[j]] <- HRO_index
HRO_matrix[individual_ids[j], individual_ids[i]] <- HRO_index
}
}
}
HRO(dolph.kernel.poly)
library(rgeos)
HRO <- function(kernel.poly) {
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(kernel.poly)
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = list(kernel.poly@data$id, kernel.poly@data$id))
# For loop to calculate HRO for each pair
for (i in 1:n_individuals) {
for (j in (i+1):n_individuals) {
# Get the home range polygons for individuals i and j
poly_i <- kernel.poly[[i]]
poly_j <- kernel.poly[[j]]
# Calculate the overlap area between the home ranges (Rij)
O_area <- gArea(gIntersection(poly_i, poly_j))
# Calculate the home range area for individuals i and j (Ri and Rj)
home_range_area_i <- gArea(poly_i)
home_range_area_j <- gArea(poly_j)
# Calculate HRO using the formula: HRO = (Rij/Ri) * (Rij/Rj)
HRO_index <- (O_area / home_range_area_i) * (O_area / home_range_area_j)
# Store the HRO value in the matrix
HRO_matrix[individual_ids[i], individual_ids[j]] <- HRO_index
HRO_matrix[individual_ids[j], individual_ids[i]] <- HRO_index
}
}
}
HRO(dolph.kernel.poly)
dolph.kernel.poly=kernel.poly
dolph.kernel.poly <- kernel.poly
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly)
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = list(dolph.kernel.poly@data$id, dolph.kernel.poly@data$id))
# For loop to calculate HRO for each pair
for (i in 1:n_individuals) {
for (j in (i+1):n_individuals) {
# Get the home range polygons for individuals i and j
poly_i <- dolph.kernel.poly[[i]]
poly_j <- dolph.kernel.poly[[j]]
# Calculate the overlap area between the home ranges (Rij)
O_area <- gArea(gIntersection(poly_i, poly_j))
# Calculate the home range area for individuals i and j (Ri and Rj)
home_range_area_i <- gArea(poly_i)
home_range_area_j <- gArea(poly_j)
# Calculate HRO using the formula: HRO = (Rij/Ri) * (Rij/Rj)
HRO_index <- (O_area / home_range_area_i) * (O_area / home_range_area_j)
# Store the HRO value in the matrix
HRO_matrix[individual_ids[i], individual_ids[j]] <- HRO_index
HRO_matrix[individual_ids[j], individual_ids[i]] <- HRO_index
}
}
library(raster)
HRO <- function(dolph.kernel.poly) {
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly)
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = list(dolph.kernel.poly@data$id, dolph.kernel.poly@data$id))
# For loop to calculate HRO for each pair
for (i in 1:n_individuals) {
for (j in (i+1):n_individuals) {
# Get the home range polygons for individuals i and j
poly_i <- dolph.kernel.poly[[i]]
poly_j <- dolph.kernel.poly[[j]]
# Calculate the overlap area between two polygons
if (length(gIntersection(poly_i, poly_j)) == 0) {
return(0)  # No intersection, return 0
} else {
return(gArea(gIntersection(poly1, poly2)))
}
# Calculate the home range area for individuals i and j (Ri and Rj)
home_range_area_i <- gArea(poly_i)
home_range_area_j <- gArea(poly_j)
# Calculate HRO using the formula: HRO = (Rij/Ri) * (Rij/Rj)
HRO_index <- (O_area / home_range_area_i) * (O_area / home_range_area_j)
# Store the HRO value in the matrix
HRO_matrix[individual_ids[i], individual_ids[j]] <- HRO_index
HRO_matrix[individual_ids[j], individual_ids[i]] <- HRO_index
}
}
}
HRO(dolph.kernel.poly)
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly)
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = list(dolph.kernel.poly@data$id, dolph.kernel.poly@data$id))
# Check and filter invalid geometries
for (i in 1:n_individuals) {
if (!st_is_valid(dolph.kernel.poly[[i]])) {
# Attempt to fix invalid geometry or remove it
dolph.kernel.poly[[i]] <- st_make_valid(dolph.kernel.poly[[i]])
if (is.null(dolph.kernel.poly[[i]])) {
# Remove invalid geometry if it cannot be fixed
dolph.kernel.poly <- dolph.kernel.poly[-i]
dolph.kernel.poly@data$id <- dolph.kernel.poly@data$id[-i]
n_individuals <- n_individuals - 1
HRO_matrix <- HRO_matrix[-i, -i]
}
}
}
# Check and filter invalid geometries
valid_indices <- which(sapply(dolph.kernel.poly, function(x) !st_is_empty(x)))
valid_indices
# Check and filter invalid geometries
valid_indices <- c()
for (i in 1:n_individuals) {
if (!st_is_empty(dolph.kernel.poly[[i]])) {
valid_indices <- c(valid_indices, i)
}
}
for (i in 1:n_individuals) {
if (inherits(dolph.kernel.poly[[i]], "sf")) {
if (!st_is_empty(dolph.kernel.poly[[i]])) {
valid_indices <- c(valid_indices, i)
}
} else {
dolph.kernel.poly[[i]] <- st_as_sf(dolph.kernel.poly[[i]])
if (!st_is_empty(dolph.kernel.poly[[i]])) {
valid_indices <- c(valid_indices, i)
}
}
}
for (i in 1:n_individuals) {
if (st_is(dolph.kernel.poly[[i]], "sf")) {
if (!st_is_empty(dolph.kernel.poly[[i]])) {
valid_indices <- c(valid_indices, i)
}
} else {
converted_sf <- tryCatch(st_as_sf(dolph.kernel.poly[[i]]), error = function(e) NULL)
if (!is.null(converted_sf) && !st_is_empty(converted_sf)) {
dolph.kernel.poly[[i]] <- converted_sf
valid_indices <- c(valid_indices, i)
}
}
}
for (i in 1:n_individuals) {
if (inherits(dolph.kernel.poly[[i]], "sf")) {
if (!st_is_empty(dolph.kernel.poly[[i]]$geometry)) {
valid_indices <- c(valid_indices, i)
}
} else {
converted_sf <- tryCatch(st_as_sf(dolph.kernel.poly[[i]]), error = function(e) NULL)
if (!is.null(converted_sf) && !st_is_empty(converted_sf$geometry)) {
dolph.kernel.poly[[i]] <- converted_sf
valid_indices <- c(valid_indices, i)
}
}
}
for (i in 1:n_individuals) {
if (inherits(dolph.kernel.poly[[i]], "sf")) {
if (!st_is_empty(dolph.kernel.poly[[i]]$geometry)) {
valid_indices <- c(valid_indices, i)
}
} else {
converted_sf <- tryCatch(st_as_sf(dolph.kernel.poly[[i]]), error = function(e) NULL)
if (!is.null(converted_sf) && !st_is_empty(converted_sf$geometry)) {
dolph.kernel.poly[[i]] <- converted_sf
valid_indices <- c(valid_indices, i)
}
}
}
# Check if there are any valid individuals before proceeding
if (length(valid_indices) == 0) {
stop("No valid individuals with non-empty home ranges.")
}
for (i in 1:n_individuals) {
if (inherits(dolph.kernel.poly[[i]], "sf")) {
if (!st_is_empty(dolph.kernel.poly[[i]]$geometry)) {
valid_indices <- c(valid_indices, i)
}
} else {
converted_sf <- tryCatch(st_as_sf(dolph.kernel.poly[[i]]), error = function(e) NULL)
if (!is.null(converted_sf) && !st_is_empty(converted_sf$geometry)) {
dolph.kernel.poly[[i]] <- converted_sf
valid_indices <- c(valid_indices, i)
}
}
}
# Check if there are any valid individuals before proceeding
if (length(valid_indices) == 0) {
stop("No valid individuals with non-empty home ranges.")
}
# Check and filter invalid geometries
valid_indices <- c()
for (i in 1:n_individuals) {
if (inherits(dolph.kernel.poly[[i]], "sf") && st_is_valid(dolph.kernel.poly[[i]])) {
valid_indices <- c(valid_indices, i)
} else {
converted_sf <- tryCatch(st_as_sf(dolph.kernel.poly[[i]]), error = function(e) NULL)
if (!is.null(converted_sf) && st_is_valid(converted_sf)) {
dolph.kernel.poly[[i]] <- converted_sf
valid_indices <- c(valid_indices, i)
}
}
}
# Check if there are any valid individuals before proceeding
if (length(valid_indices) == 0) {
stop("No valid individuals with non-empty home ranges.")
}
# Check and filter invalid geometries
valid_indices <- c()
for (i in 1:n_individuals) {
if (inherits(dolph.kernel.poly[[i]], "sf") && st_is_valid(dolph.kernel.poly[[i]])) {
valid_indices <- c(valid_indices, i)
} else {
message(paste("Individual", dolph.kernel.poly@data$id[i], "has an empty home range and will be excluded."))
}
}
# Check if there are any valid individuals before proceeding
if (length(valid_indices) == 0) {
stop("No valid individuals with non-empty home ranges.")
}
dolph.kernel.poly <- dolph.kernel.poly[valid_indices]
individual_ids <- individual_ids[valid_indices]
individual_ids <- dolph.kernel.poly@data$id[valid_indices]
HRO_matrix <- HRO_matrix[valid_indices, valid_indices]
View(HRO_matrix)
# For loop to calculate HRO for each pair
for (i in 1:n_individuals) {
for (j in (i+1):n_individuals) {
# Get the home range polygons for individuals i and j
poly_i <- dolph.kernel.poly[[i]]
poly_j <- dolph.kernel.poly[[j]]
# Calculate the overlap area between two polygons
if (length(gIntersection(poly_i, poly_j)) == 0) {
return(0)  # No intersection, return 0
} else {
return(gArea(gIntersection(poly1, poly2)))
}
# Calculate the home range area for individuals i and j (Ri and Rj)
home_range_area_i <- gArea(poly_i)
home_range_area_j <- gArea(poly_j)
# Calculate HRO using the formula: HRO = (Rij/Ri) * (Rij/Rj)
HRO_index <- (O_area / home_range_area_i) * (O_area / home_range_area_j)
# Store the HRO value in the matrix
HRO_matrix[individual_ids[i], individual_ids[j]] <- HRO_index
HRO_matrix[individual_ids[j], individual_ids[i]] <- HRO_index
}
}
HRO_matrix
# Check and filter invalid geometries
valid_indices <- c()
for (i in 1:n_individuals) {
if (inherits(dolph.kernel.poly[[i]], "sf") && st_is_valid(dolph.kernel.poly[[i]])) {
valid_indices <- c(valid_indices, i)
} else {
message(paste("Individual", dolph.kernel.poly@data$id[i], "has an empty home range and will be excluded."))
}
}
# Check if there are any valid individuals before proceeding
if (length(valid_indices) == 0) {
stop("No valid individuals with non-empty home ranges.")
}
valid_indices
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly)
n_individuals
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly@data$id)
n_individuals
View(dolph.kernel.poly)
dolph.kernel.poly
# 95% of estimated distribution
dolph.kernel.poly <- getverticeshr(kernel.lscv, percent = 95)
print(dolph.kernel.poly)  # returns the area of each polygon
View(dolph.kernel.poly)
# Check and filter invalid geometries
valid_indices <- c()
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly@data$id)
n_individuals
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = list(dolph.kernel.poly@data$id, dolph.kernel.poly@data$id))
HRO_matrix
# Check and filter invalid geometries
valid_indices <- c()
for (i in 1:n_individuals) {
if (inherits(dolph.kernel.poly[[i]], "sf") && st_is_valid(dolph.kernel.poly[[i]])) {
valid_indices <- c(valid_indices, i)
} else {
message(paste("Individual", dolph.kernel.poly@data$id[i], "has an empty home range and will be excluded."))
}
}
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly@data$id)
n_individuals
# Check and filter invalid geometries
valid_indices <- c()
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly@data$id)
n_individuals
for (i in 1:n_individuals) {
if (inherits(dolph.kernel.poly[[i]], "sf") && st_is_valid(dolph.kernel.poly[[i]])) {
valid_indices <- c(valid_indices, i)
} else {
message(paste("Individual", dolph.kernel.poly$id[i], "has an empty home range and will be excluded."))
}
}
valid_indices
# Filter the individuals with empty home ranges
dolph.kernel.poly <- dolph.kernel.poly[valid_indices]
dolph.geo <- dolph.geo[valid_indices, ]
n_individuals <- length(dolph.kernel.poly)
n_individuals
HRO_matrix <- HRO_matrix[valid_indices, valid_indices]
HRO_matrix
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals, dimnames = list(dolph.kernel.poly@data$id, dolph.kernel.poly@data$id))
# Loop through each pair of individuals to calculate HRO
for (i in 1:n_individuals) {
for (j in (i+1):n_individuals) {
# Get the home range polygons for individuals i and j
poly_i <- dolph.kernel.poly[[i]]$geometry
poly_j <- dolph.kernel.poly[[j]]$geometry
# Calculate the intersection area between the home ranges (Rij)
intersect_area <- intersection_area(poly_i, poly_j)
# Calculate the home range area for individuals i and j (Ri and Rj)
home_range_area_i <- st_area(poly_i)
home_range_area_j <- st_area(poly_j)
# Calculate HRO using the formula: HRO = (Rij/Ri) * (Rij/Rj)
HRO_value <- (intersect_area / home_range_area_i) * (intersect_area / home_range_area_j)
# Store the HRO value in the matrix
HRO_matrix[dolph.kernel.poly$id[i], dolph.kernel.poly$id[j]] <- HRO_value
HRO_matrix[dolph.kernel.poly$id[j], dolph.kernel.poly$id[i]] <- HRO_value
}
}
dolph.kernel.poly$id
dolph.kernel.poly@data$id
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly@data$id)
n_individuals
# 95% of estimated distribution
dolph.kernel.poly <- getverticeshr(kernel.lscv, percent = 95)
# Empty matrix to store HRO values for each pair of individuals
n_individuals <- length(dolph.kernel.poly@data$id)
n_individuals
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals,
dimnames = list(dolph.kernel.poly@data$id, dolph.kernel.poly@data$id))
HRO_matrix
dolph.kernel.poly[[i]]$geometry
n_individuals <- length(dolph.kernel.poly@data$id)
n_individuals
HRO_matrix <- matrix(NA, nrow = n_individuals, ncol = n_individuals,
dimnames = list(dolph.kernel.poly@data$id, dolph.kernel.poly@data$id))
dolph.kernel.poly[[i]]
dolph.kernel.poly[[1]]
View(dolph.kernel.poly)
dolph.kernel.poly@polygons[[i]]
dolph.kernel.poly@polygons[[j]]
# Get the home range polygons for individuals i and j
poly_i <- dolph.kernel.poly@polygons[[i]]
poly_j <- dolph.kernel.poly@polygons[[j]]
# Calculate the intersection area between the home ranges (Rij)
intersect_area <- intersection_area(poly_i, poly_j)
# Calculate the intersection area between the home ranges (Rij)
intersect_area <-
if (st_is_empty(st_intersection(poly_i, poly_j))) {
return(0)  # No intersection, return 0
} else {
return(st_area(st_intersection(poly_i, poly_j)))
}
st_area(st_intersection(poly_i, poly_j))
library(sp) # Creates a SpatialPointsDataFrame by defining the coordinates
# Calculate the intersection area between the home ranges (Rij)
intersection_area <- function(poly1, poly2) {
if (is.null(gIntersects(poly1, poly2))) {
return(0)  # No intersection, return 0
} else {
intersect_poly <- gIntersection(poly1, poly2)
return(gArea(intersect_poly))
}
}
intersect_area <- intersection_area(poly_i, poly_j)
# Get the home range polygons for individuals i and j
poly_i <- dolph.kernel.poly[[i]]
poly_j <- dolph.kernel.poly[[j]]
# Calculate the intersection area between the home ranges (Rij)
intersection_area <- function(poly1, poly2) {
if (is.null(gIntersects(poly1, poly2))) {
return(0)  # No intersection, return 0
} else {
intersect_poly <- gIntersection(poly1, poly2)
return(gArea(intersect_poly))
}
}
intersect_area <- intersection_area(poly_i, poly_j)
View(dolph.kernel.poly)
dolph.kernel.poly[[i]]$geometry
library(rgdal) # Overlap
install.packages("rgdal")
library(rgdal) # Overlap
kov <- kerneloverlaphr(kernel.lscv, method="HR", lev=95)
kov
