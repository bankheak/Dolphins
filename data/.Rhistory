knitr::opts_chunk$set(echo = TRUE)
N_0 <- 300
N_1 <- 300 + 630 - 517
lambda <- N_1/N_0
# N(t+1)/N(t)
lambda <- N_1/N_0
r <- log(lambda)
# N(t + 1) = $\lambda$*N(t)
t <- c(1:14)
N_14 <- lambda * (N_0 * t)
N_14
# N(t + 1) = $\lambda$*N(t)
t <- c(1:14)
N <- lambda * exp(r * t)
# N(t + 1) = $\lambda$*N(t)
t <- c(0:14)
N <- lambda * exp(r * t)
# N(t + 1) = $\lambda$*N(t)
t <- c(0:14)
N <- N_0 * exp(r * t)
plot(t, N, xlab = "Time (Days)", ylab = "Poplulation Size (Number of Beetles)")
N_0 <- 300
N_1 <- 300 + 361 - 410
N_0 <- 300
N_1 <- 300 + 361 - 410
lambda <- N_1/N_0
r <- log(lambda)
t <- c(0:14)
N <- N_0 * exp(r * t)
plot(t, N, xlab = "Time (Days)", ylab = "Poplulation Size (Number of Beetles)")
N[15]
# read in data
kemps <- read.csv("Lab3-4_KempsRidleyTurtleData.csv")
View(kemps)
# read in data
kemps <- read.csv("Lab3-4_KempsRidleyTurtleData.csv")
# plot population size vs. years
plot(kemps$Year, kemps$Nests,xlab="Years",ylab="Number of Nests")
# read in data
kemps <- read.csv("Lab3-4_KempsRidleyTurtleData.csv")
# plot population size vs. years
plot(kemps$Year, kemps$Nests,xlab="Years",ylab="Number of Nests")
# The population is exponentially increasing in size over
# help info for lm. "base::" is specified just in case you have another package loaded with a function called lm. It indicates that we want the lm function in base R
?base::lm
?lm
View(kemps)
kempslognests <- log(kemps$Nests)
# help info for lm. "base::" is specified just in case you have another package loaded with a function called lm. It indicates that we want the lm function in base R
?base::lm
#lambda <- N_1/N_0 & r <- log(lambda)
kemps$lognests <- log(kemps$Nests)
reg <- lm(lognests ~ Year, data = kemps)
coef(reg)
confint(reg)
summary(reg)
# help info for lm. "base::" is specified just in case you have another package loaded with a function called lm. It indicates that we want the lm function in base R
?base::lm
kemps$lognests <- log(kemps$Nests)
reg <- lm(lognests ~ Year, data = kemps)
coef(reg)
confint(reg)
summary(reg)
confint(reg)
plot(kemps$Year,log(kemps$Nests),xlab="Year",ylab="Number of Nests")
lines(kemps$Year,predict(reg))
plot(kemps$Year,log(kemps$Nests),xlab="Year",ylab="Number of Nests", pch = 2)
lines(kemps$Year,predict(reg))
?pch
plot(kemps$Year,log(kemps$Nests),xlab="Year",ylab="Number of Nests", pch = 20)
lines(kemps$Year,predict(reg))
plot(kemps$Year,log(kemps$Nests),xlab="Year",ylab="Number of Nests", pch = 20, type = "b")
plot(kemps$Year,log(kemps$Nests),xlab="Year",ylab="Number of Nests", pch = 20, type = "b")
lines(kemps$Year,predict(reg))
plot(kemps$Year,kemps$Nests,xlab="Year",ylab="Number of Nests", pch = 20)
lines(kemps$Year,exp(predict(reg)))
coef(reg)
coef(reg)["Year"]
?abs()
r <- coef(reg)["Year"]
lambda <- 1/log(r)
perc_change <- abs(lambda - 1) * 100
r <- coef(reg)["Year"]
lambda <- 1/log(r)
lambda <- coef(reg)["Year"]
r <- log(lambda)
perc_change <- abs(lambda - 1) * 100
r <- coef(reg)["Year"]
lambda <- exp(r)
perc_change <- (lambda - 1) * 100
logger <- read.csv("Lab3-4_LoggerheadTurtleData.csv")
View(logger)
logger <- read.csv("Lab3-4_LoggerheadTurtleData.csv")
plot(logger$Year, logger$Nests, xlab="Year", ylab="Number of Nests", pch = 20)
logger$lognests <- log(logger$Nests)
reg2 <- lm(lognests ~ Year, data = logger)
coef(reg2)
confint(reg2)
summary(reg2)
coef(reg2)
confint(reg2)
summary(reg2)
data_1 <- read.csv("Lab3-4_dataset1.csv")
View(data_1)
data_1 <- read.csv("Lab3-4_dataset1.csv")
plot(data_1$years, data_1$Population, xlab="Years", ylab="Population Size", pch = 20)
data_1 <- read.csv("Lab3-4_dataset1.csv")
plot(data_1$years, data_1$Population, xlab="Years", ylab="Population Size", pch = 20)
data_1$lambda <- data_1$Population/data_1$Population[-1]
Pop_t <- data_1$Population[1:29]
Pop_t1 <- data_1$Population[2:30]
lambda <- Pop_t1/Pop_t
r <- log(lambda)
hist(r)
mu <- mean(r)
sigma <- sd(r)
knitr::opts_chunk$set(echo = TRUE)
N_0 <- 300
N_1 <- 300 + 630 - 517
# N(t+1)/N(t)
lambda <- N_1/N_0
r <- log(lambda)
# N(t + 1) = $\lambda$*N(t)
t <- c(0:14)
N <- N_0 * exp(r * t)
N
knitr::opts_chunk$set(echo = TRUE)
#maximum intrinsic growth rate
r <- 0.3
# carrying capacity
K <- 500
# initial population size
N0 <- 5
#maximum intrinsic growth rate
r <- 0.3
# carrying capacity
K <- 500
# initial population size
N0 <- 5
numyears <- 50
N <- rep(NA, numyears) #makes an empty vector (NA) with length numyears. This is an easy way to make an object to fill
N[1] <- N0 #initialize the vector for the first year
for(t in 1:(numyears-1)){  #Note the indexing from 1 to (numyears-1) so that the last element in the vector is N[numyears] and not N[numyears+1], which is bigger than the vector we made
#N[t+1] <- #Use the appropriate equation
}
numyears <- 50
N <- rep(NA, numyears) #makes an empty vector (NA) with length numyears. This is an easy way to make an object to fill
N[1] <- N0 #initialize the vector for the first year
for(t in 1:(numyears-1)){  #Note the indexing from 1 to (numyears-1) so that the last element in the vector is N[numyears] and not N[numyears+1], which is bigger than the vector we made
N[t+1] <- N[t] + r * N[t]*(1 - N[t]/K) #Use the appropriate equation
}
N
numyears <- 50
N <- rep(NA, numyears) #makes an empty vector (NA) with length numyears. This is an easy way to make an object to fill
N[1] <- N0 #initialize the vector for the first year
for(t in 1:(numyears-1)){  #Note the indexing from 1 to (numyears-1) so that the last element in the vector is N[numyears] and not N[numyears+1], which is bigger than the vector we made
N[t+1] <- N[t] + r * N[t]*(1 - N[t]/K) #Use the appropriate equation
}
# Plot through time
plot(1:numyears, N)
plot(N[1:49], N[2:50])
change <- N[2:50] - N[1:49]
dt <- 1
changeN <- (N_t1 - N_t)/dt
N_t <- N[1:49]
N_t1 <- N[2:50]
plot(N_t, N_t1)
dt <- 1
changeN <- (N_t1 - N_t)/dt
plot(N_t, changeN)
lambda <- N_t1/N_t
plot(lambda, N_t)
dt <- 1
changeN <- (N_t1 - N_t)/dt
plot(N_t, changeN)
lambda <- N_t1/N_t
plot(lambda, N_t)
N_t <- N[1:49]
N_t1 <- N[2:50]
plot(N_t, N_t1)
lambda <- N_t1/N_t
plot(lambda, N_t)
#maximum intrinsic growth rate
r <- 0.6
# carrying capacity
K <- 500
# initial population size
N0 <- 5
numyears <- 50
N <- rep(NA, numyears) #makes an empty vector (NA) with length numyears. This is an easy way to make an object to fill
N[1] <- N0 #initialize the vector for the first year
for(t in 1:(numyears-1)){  #Note the indexing from 1 to (numyears-1) so that the last element in the vector is N[numyears] and not N[numyears+1], which is bigger than the vector we made
N[t+1] <- N[t] + r * N[t]*(1 - N[t]/K) #Use the appropriate equation
}
# Plot through time
plot(1:numyears, N)
lambda <- N_t1/N_t
plot(N_t, lambda)
# Set working directory here
setwd("../data")
setwd("C:/Users/bankh/My_Repos/Dolphins/code")
# Set working directory here
setwd("../data")
# Load all necessary packages
library(tnet) # For weights
library(igraph) # Measure centrality here
library(ggraph)
library(grid)
library(assortnet) # associative indices
library(ggplot2) # Visualization
library(abind) # array
library(MCMCglmm) # MCMC models
library(coda)
library(bayesplot) # plot parameters
library(doParallel)
source("../code/functions.R") # Matrix_to_edge_list
N_0 = 12
r = 0.08
K = 250
numyears <- 50
N <- rep(NA, numyears) #makes an empty vector (NA) with length numyears. This is an easy way to make an object to fill
N[1] <- N_0 #initialize the vector for the first year
for(t in 1:(numyears-1)){  #Note the indexing from 1 to (numyears-1) so that the last element in the vector is N[numyears] and not N[numyears+1], which is bigger than the vector we made
N[t+1] <- N[t] + r * N[t]*(1 - N[t]/K) #Use the appropriate equation
}
N_t <- N[1:49]
N_t1 <- N[2:50]
dt <- 1
changeN <- (N_t1 - N_t)/dt
plot(N_t, changeN)
250/2
plot(N_t, changeN)
abline(half)
?abline
N_0 = 12
r = 0.08
K = 250
half = 250/2
numyears <- 50
N <- rep(NA, numyears) #makes an empty vector (NA) with length numyears. This is an easy way to make an object to fill
N[1] <- N_0 #initialize the vector for the first year
for(t in 1:(numyears-1)){  #Note the indexing from 1 to (numyears-1) so that the last element in the vector is N[numyears] and not N[numyears+1], which is bigger than the vector we made
N[t+1] <- N[t] + r * N[t]*(1 - N[t]/K) #Use the appropriate equation
}
N_t <- N[1:49]
N_t1 <- N[2:50]
dt <- 1
changeN <- (N_t1 - N_t)/dt
plot(N_t, changeN)
abline(h = half)
N_0 = 12
r = 0.08
K = 250
half = 250/2
numyears <- 50
N <- rep(NA, numyears) #makes an empty vector (NA) with length numyears. This is an easy way to make an object to fill
N[1] <- N_0 #initialize the vector for the first year
for(t in 1:(numyears-1)){  #Note the indexing from 1 to (numyears-1) so that the last element in the vector is N[numyears] and not N[numyears+1], which is bigger than the vector we made
N[t+1] <- N[t] + r * N[t]*(1 - N[t]/K) #Use the appropriate equation
}
N_t <- N[1:49]
N_t1 <- N[2:50]
dt <- 1
changeN <- (N_t1 - N_t)/dt
plot(N_t, changeN)
abline(v = half)
K=250
r=0.08
r*K/4
nxn <- readRDS("nxn.RData") # association matrix of list_years
## Create social network
ig_func <- function(nxn) {
ig <- lapply(nxn, function (df) {
graph_from_adjacency_matrix(
df,
mode = "undirected",
weighted = TRUE,
diag = FALSE)})
return(ig)}
ig <- ig_func(nxn)
# Set the node names based on row names
row_name_assign <- function(nxn, ig) {
row_names <- lapply(nxn, function (df) {rownames(df)})
for (i in seq_along(ig)) {
V(ig[[i]])$name <- row_names[[i]]
}
}
row_name_assign(nxn, ig)
# Only show IDs of HI dolphins
HI_list <- readRDS("HI_list.RData")
HI_list <- HI_list[-4] # Get rid of natural foragers
# Read in centrality data
result_df <- readRDS("result_df.RData")
centrality_matrix <- matrix(c(mean(result_df$Degree[result_df$HI == "BG" & result_df$Period == "1-Before_HAB"]),
mean(result_df$Degree[result_df$HI == "BG" & result_df$Period == "2-During_HAB"]),
mean(result_df$Degree[result_df$HI == "BG" & result_df$Period == "3-After_HAB"]),
mean(result_df$Degree[result_df$HI == "FG" & result_df$Period == "1-Before_HAB"]),
mean(result_df$Degree[result_df$HI == "FG" & result_df$Period == "2-During_HAB"]),
mean(result_df$Degree[result_df$HI == "FG" & result_df$Period == "3-After_HAB"]),
mean(result_df$Degree[result_df$HI == "SD" & result_df$Period == "1-Before_HAB"]),
mean(result_df$Degree[result_df$HI == "SD" & result_df$Period == "2-During_HAB"]),
mean(result_df$Degree[result_df$HI == "SD" & result_df$Period == "3-After_HAB"])),
nrow = 3, ncol = 3)
centrality_matrix <- round(centrality_matrix, 2)
# Plot network
# Set up the plotting area with 1 row and 2 columns for side-by-side plots
par(mfrow = c(3, 3), mar = c(0.8, 0.8, 0.8, 0.8))
# Loop through the list of graphs and plot them side by side
for (i in 1:length(ig)) {
combined_layout <- layout_with_fr(ig[[i]])
counter <- 0
for (j in HI_list) {
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- V(ig[[i]])$name %in% j[[i]]
plot(ig[[i]],
layout = combined_layout,
edge.width = E(ig[[i]])$weight * 4, # edge thickness
vertex.size = sqrt(igraph::strength(ig[[i]], vids = V(ig[[i]]), mode = c("all"), loops = TRUE) * 10), # Changes node size based on an individuals strength (centrality)
vertex.frame.color = NA,
vertex.label.family = "Helvetica",
vertex.label = ifelse(labeled_nodes, V(ig[[i]])$name, NA),
vertex.label.color = "black",
vertex.label.cex = 0.8,
vertex.label.dist = 2,
vertex.frame.width = 0.01,
vertex.color = ifelse(labeled_nodes, "red", "grey"))
# Add the plot with a box around it
box()
# Add a number in the right corner
text(1, 1, centrality_matrix[i, counter], pos = 4, cex = 1.2, col = "black")
}
}
r = 0.11
K = 11500 * 2
r*K/4
# dN/dt - rN(1-(N/K))
N = 14000
r*N*(1-N/K)
r = 0.11
K = 11500 * 2
r*K/4
# dN/dt - rN(1-(N/K))
N = 14000
change <- r*N*(1-N/K)
change - same
r = 0.11
K = 11500 * 2
same <- r*K/4
# dN/dt - rN(1-(N/K))
N = 14000
change <- r*N*(1-N/K)
change - same
##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 8
Recruits_turkey <- alpha*N*exp(-beta*N)
Recruits_turkey
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
N = 14
Recruits_grouse = 1/(alpha + beta/N)
Recruits_grouse
##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 1:800
Recruits_turkey <- alpha*N*exp(-beta*N)
Recruits_turkey
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
Recruits_grouse = 1/(alpha + beta/N)
Recruits_grouse
##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 1:800
Recruits_turkey <- alpha*N*exp(-beta*N)
plot(N, Recruits_turkey, xlab = "Population Size", ylab = "Expected Recruitment")
abline(h = (N == Recruits_turkey))
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
Recruits_grouse = 1/(alpha + beta/N)
Recruits_grouse
##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 1:800
Recruits_turkey <- alpha*N*exp(-beta*N)
plot(N, Recruits_turkey, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
Recruits_grouse = 1/(alpha + beta/N)
##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 1:800
Recruits_turkey <- alpha*N*exp(-beta*N)
plot(N, Recruits_turkey, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
Recruits_grouse = 1/(alpha + beta/N)
plot(N, Recruits_grouse, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
max(Recruits_turkey)
max(Recruits_grouse)
Turkey_MSY <- which.max(R_turkey - N)
Turkey_MSY <- which.max(Recruits_turkey - N)
Turkey_MSY
?which.max
Recruits_turkey - N
Turkey_MSY <- max(Recruits_turkey - N)
Turkey_MSY
Turkey_MSY <- which.max(Recruits_turkey - N)
Grouse_MSY <- which.max(Recruits_grouse - N)
ILV_mat <-readRDS("ILV_mat_limit.RData") # Age and Sex Matrices
kov <- readRDS("kov_limit.RDS")  # Home range overlap
nxn <- readRDS("nxn_limit.RData") # Association Matrix
gr <- readRDS("kinship_matrix_limit.RData")
# Prepare random effect for MCMC
num_nodes <- lapply(nxn, function(df) dim(df)[1])
node_names <- lapply(nxn, function(df) colnames(df))
# Separate IDs into i and j
node_ids_i <- lapply(num_nodes, function(df) matrix(rep(1:df, each = df), nrow = df, ncol = df))
node_ids_j <- lapply(node_ids_i, function(df) t(df))
# Format data
upper_tri <- lapply(nxn, function(df) upper.tri(df, diag = FALSE))
edge_nxn <- abind(lapply(nxn, function(mat) mat[upper.tri(mat, diag = FALSE)]), along = 2)
## Split by 3 for int data
HAB_data <- as.data.frame(cbind(c(edge_nxn[,1], edge_nxn[,2], edge_nxn[,3]), c(rep(1, nrow(edge_nxn)), rep(2, nrow(edge_nxn)), rep(3, nrow(edge_nxn)))))
colnames(HAB_data) <- c("SRI", "HAB")
HAB_data$During <- ifelse(HAB_data$HAB == 2, 1, 0)
HAB_data$After <- ifelse(HAB_data$HAB == 3, 1, 0)
HI <- abind(lapply(sim_HI, function(mat) mat[upper.tri(mat, diag = FALSE)]), along = 2)
one <- lapply(seq_along(node_ids_i), function(i) factor(as.vector(node_names[[i]][node_ids_i[[i]][upper_tri[[i]]]]), levels = node_names[[i]]))
two <- lapply(seq_along(node_ids_j), function(i) factor(as.vector(node_names[[i]][node_ids_j[[i]][upper_tri[[i]]]]), levels = node_names[[i]]))
# Put data into a dataframe
df_list = data.frame(edge_weight = HAB_data[, 1],
HAB_During = HAB_data[, 3],
HAB_After = HAB_data[, 4],
HRO = unlist(lapply(kov, function (df) df[upper.tri(df, diag = FALSE)])),
sex_similarity = rep(ILV_mat[[1]][upper.tri(ILV_mat[[1]], diag = FALSE)], 3),
age_similarity = rep(ILV_mat[[2]][upper.tri(ILV_mat[[2]], diag = FALSE)], 3),
GR = rep(gr[upper.tri(gr, diag = FALSE)], 3),
HI_similarity = c(HI[,c(1:3)]),
node_id_1 = unlist(one),
node_id_2 = unlist(two))
# Read in limited social association matrix and listed data
sim_HI <- readRDS("sim_HI_limit.RData") # HI Sim Matrix
HI <- abind(lapply(sim_HI, function(mat) mat[upper.tri(mat, diag = FALSE)]), along = 2)
# Put data into a dataframe
df_list = data.frame(edge_weight = HAB_data[, 1],
HAB_During = HAB_data[, 3],
HAB_After = HAB_data[, 4],
HRO = unlist(lapply(kov, function (df) df[upper.tri(df, diag = FALSE)])),
sex_similarity = rep(ILV_mat[[1]][upper.tri(ILV_mat[[1]], diag = FALSE)], 3),
age_similarity = rep(ILV_mat[[2]][upper.tri(ILV_mat[[2]], diag = FALSE)], 3),
GR = rep(gr[upper.tri(gr, diag = FALSE)], 3),
HI_similarity = c(HI[,c(1:3)]),
node_id_1 = unlist(one),
node_id_2 = unlist(two))
# Check for gr
fit_mcmc.1 <- MCMCglmm(edge_weight ~ HRO + age_similarity + sex_similarity + GR,
random=~mm(node_id_1 + node_id_2), data = df_list, nitt = 20000)
summary(fit_mcmc.1)
