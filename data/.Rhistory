plot(N, Recruits_grouse, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 1:800
Recruits_turkey <- alpha*N*exp(-beta*N)
plot(N, Recruits_turkey, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
Recruits_grouse = 1/(alpha + beta/N)
plot(N, Recruits_grouse, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
Turkey_MSY <- which.max(Recruits_turkey - N)
Turkey_MSY
Grouse_MSY <- which.max(Recruits_grouse - N)
Grouse_MSY
t_vect <- Recruits_turkey - N
Turkey_MSY <- which.max(t_vect)
Turkey_MSY
t_vect <- Grouse_MSY - N
Grouse_MSY <- which.max(Recruits_grouse - N)
Grouse_MSY
t_vect
t_vect <- Recruits_turkey - N
Turkey_MSY <- which.max(t_vect)
Turkey_MSY
t_vect <- Grouse_MSY - N
Grouse_MSY <- which.max(Recruits_grouse - N)
Grouse_MSY
r <- 0.3
K <- 500
N0 <- 500
# H = 20
H = 20
numyears <- 50
N <- rep(NA, numyears)
N[1] <- N0
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0:600))
?plot
# H = 20
H = 20
numyears <- 50
N <- rep(NA, numyears)
N[1] <- N0
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N40_t, c(changeN20, changeN30, changeN40))
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N20_t, changeN20, type = 'l', col = 'blue', ylim = range(c(changeN20, changeN30, changeN40)), ylab = 'dN/dt', xlab = 'Population Size')
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N20_t, changeN20, type = 'l', col = 'blue', ylab = 'dN/dt', xlab = 'Population Size')
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
# Plot the first population
plot(N20_t, changeN20, type = 'l', col = 'blue', ylab = 'dN/dt', xlab = 'Time', main = 'Population Changes Over Time')
N=1:500
dndt=r * N * (1 - N/K)
plot(N,dndt,xlab="Population Size",ylab="dN/dt")
abline(h=20)
abline(h=30,lty=2)
abline(h=40,lty=3)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N,dndt,xlab="Population Size",ylab="dN/dt")
abline(h=20)
abline(h=30,lty=2)
abline(h=40,lty=3)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(h = 20, lyt = 2)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20, lyt = 2)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
?abline
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20)
abline(h = 30, lty = 2, lwd = 1.5)
abline(h = 40, lty = 2)
F_m = 0.2
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.3
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.4
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.2
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size")
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 1)))
(max(N_small) + 50)
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
N_small
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 50)))
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_med) + 1)))
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_large) + 1)))
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size")
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size")
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size")
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(0, 0.2)
abline(0, 0.3, lty=2)
abline(0, 0.4, lty=3)
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N_20, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
N_30[1] <- N0
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N_30, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
N_40[1] <- N0
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N_40, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
gc()
gc()
list_years <- readRDS("list_years.RData") # (1995-2000)/(2001-2006)/(2007-2012)
# Set working directory here
setwd("../data")
# Load all necessary packages
library(igraph)
library(doParallel) # Faster computing
list_years <- readRDS("list_years.RData") # (1995-2000)/(2001-2006)/(2007-2012)
nxn <- readRDS("nxn.RData") # association matrix of list_years
# Read in ig object
ig <- readRDS("ig.RData")
# Only show IDs of HI dolphins
HI_list <- readRDS("HI_list.RData")
HI_list <- HI_list[-4] # Get rid of natural foragers
HI_IDs <- unique(as.vector(unlist(HI_list))) # Put them all together
#----Modularity---
# igraph format with weight
el_years <- readRDS("el_years.RData")
n.cores <- detectCores()
registerDoParallel(n.cores)
dolphin_ig <- list()
for (j in seq_along(list_years)) {
dolphin_ig[[j]] <- graph_from_adjacency_matrix(as.matrix(nxn[[j]]),
mode="undirected",
weighted=TRUE, diag=FALSE)
}
# Modularity by the WalkTrap algorithm
dolphin_walk <- list()
for (k in seq_along(list_years)) {
dolphin_walk[[k]] <- cluster_walktrap(dolphin_ig[[k]], weights = E(dolphin_ig[[k]])$weight,
steps = 4, merges = TRUE, modularity = TRUE, membership = TRUE)
}
# Create an unweighted network
dolp_ig <- list()
for (l in seq_along(list_years)) {
dolp_ig[[l]] <- graph_from_edgelist(el_years[[l]][,1:2])
# Add the edge weights to this network
E(dolp_ig[[l]])$weight <- as.numeric(el_years[[l]][,3])
# Create undirected network
dolp_ig[[l]] <- as.undirected(dolp_ig[[l]])
}
### End parallel processing
stopImplicitCluster()
# Newman's Q modularity
newman <- lapply(dolp_ig, function (df) {
cluster_leading_eigen(df, steps = -1, weights = E(df)$weight,
start = NULL, options = arpack_defaults(),
callback = NULL, extra = NULL, env = parent.frame())
})
saveRDS(newman, "newman.RData")
# Generate a vector of colors based on the number of unique memberships
for (i in seq_along(dolp_ig)) {
# Generate a vector of colors based on the number of unique memberships
col <- rainbow(max(newman[[i]]$membership))
# Initialize the color attribute with NA
V(dolp_ig[[i]])$color <- NA
# Loop through each membership value and assign colors to corresponding vertices
for (j in 1:max(newman[[i]]$membership)){
V(dolp_ig[[i]])$color[newman[[i]]$membership == j] <- rep(col[j], sum(newman[[i]]$membership == j))
}
}
for (i in 1:length(ig)) {  # Loop through periods
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
}
counter <- 0
for (i in 1:length(ig)) {  # Loop through periods
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
}
labeled_nodes <- list()
for (i in 1:length(ig)) {  # Loop through periods
counter <- counter + 1
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
}
View(labeled_nodes)
# What is the group size?
labeled_nodes[[1]]
newman[[1]]$membership
length(newman[[1]]$membership)
membership_counts <- table(newman[[1]]$membership)
membership_counts
# What is the group size?
member_data <- data.frame(Group = newman[[1]]$membership, HI = labeled_nodes[[1]])
member_data
# What is the cluster size?
member_data <- data.frame(Cluster = newman[[1]]$membership, HI = labeled_nodes[[1]])
member_data
# What is the cluster size?
member_data <- data.frame(Cluster = newman[[2]]$membership, HI = labeled_nodes[[2]])
member_data
membership_counts <- table(newman[[2]]$membership)
membership_counts
HI_clusters <- member_data[,"HI" == T]
HI_clusters
HI_clusters <- member_data["HI" == T,]
HI_clusters
HI_clusters <- member_data[member_data$HI == T]
HI_clusters <- member_data[,member_data$HI == T]
HI_clusters <- member_data[member_data$HI == T,]
HI_clusters
unique(HI_clusters$Cluster)
membership_counts
HI_counts <- table(HI_clusters$Cluster)
HI_counts
combined_table <- cbind(HI_counts, membership_counts)
# Ensure both tables have the same keys
all_keys <- 1:7
# Add missing keys to HI_counts with counts of zero
HI_counts <- c(HI_counts, setNames(rep(0, sum(!names(HI_counts) %in% all_keys)), all_keys[!all_keys %in% names(HI_counts)]))
# What is the cluster size?
member_data <- data.frame(Cluster = newman[[2]]$membership, HI = labeled_nodes[[2]])
HI_clusters <- member_data[member_data$HI == T,]
HI_counts <- table(HI_clusters$Cluster)
membership_counts <- table(newman[[2]]$membership)
# Ensure both tables have the same keys
all_keys <- 1:7
# Create a named vector for HI_counts with counts of zero for missing keys
HI_counts <- as.table(HI_counts)
HI_counts[as.character(all_keys)] <- HI_counts[as.character(all_keys)]
HI_counts[is.na(HI_counts)] <- 0
HI_counts
# Combine the tables column-wise
combined_table <- cbind(HI_counts, membership_counts)
combined_table
membership_counts
## Turn data into data frame
membership_counts <- as.data.frame(membership_counts)
membership_counts
HI_counts <- as.data.frame(HI_counts)
HI_counts
## Create a named vector for HI_counts with counts of zero for missing keys
HI_counts <- as.table(HI_counts)
HI_counts[as.character(all_keys)] <- HI_counts[as.character(all_keys)]
HI_counts[is.na(HI_counts)] <- 0
HI_counts <- as.data.frame(HI_counts)
HI_counts_df <- data.frame(Cluster = as.numeric(names(HI_counts)), HI_Cluster_Count = as.numeric(HI_counts))
HI_counts_df
membership_counts <- table(newman[[2]]$membership)
## Turn data into data frame
membership_counts_df <- data.frame(Cluster = as.numeric(names(membership_counts)), HI_Cluster_Count = as.numeric(membership_counts))
membership_counts_df
## Turn data into data frame
membership_counts_df <- data.frame(Cluster = as.numeric(names(membership_counts)), Total_Cluster_Count = as.numeric(membership_counts))
membership_counts_df
combined_cluster_data <- merge(HI_counts_df, membership_counts_df, all = T)
combined_cluster_data
combined_cluster_data$perc_HI <- combined_cluster_data$HI_Cluster_Count/combined_cluster_data$Total_Cluster_Count
combined_cluster_data
combined_cluster_data$perc_HI <- (combined_cluster_data$HI_Cluster_Count/combined_cluster_data$Total_Cluster_Count) *100
combined_cluster_data
# What is the cluster size for each period?
combined_cluster_data <- list()
for (i in 1:3) {
## Get the member data from newman and HI data from labeled_nodes
member_data <- data.frame(Cluster = newman[[i]]$membership, HI = labeled_nodes[[i]])
HI_clusters <- member_data[member_data$HI == T,]
HI_counts <- table(HI_clusters$Cluster)
membership_counts <- table(newman[[i]]$membership)
## Ensure both tables have the same keys
all_keys <- 1:(length(unique(newman[[1]]$membership)))
## Create a named vector for HI_counts with counts of zero for missing keys
HI_counts <- as.table(HI_counts)
HI_counts[as.character(all_keys)] <- HI_counts[as.character(all_keys)]
HI_counts[is.na(HI_counts)] <- 0
## Turn data into data frame
membership_counts_df <- data.frame(Cluster = as.numeric(names(membership_counts)), Total_Cluster_Count = as.numeric(membership_counts))
HI_counts_df <- data.frame(Cluster = as.numeric(names(HI_counts)), HI_Cluster_Count = as.numeric(HI_counts))
combined_cluster_data[[i]] <- merge(HI_counts_df, membership_counts_df, all = T)
combined_cluster_data[[i]]$perc_HI <- (combined_cluster_data[[i]]$HI_Cluster_Count/combined_cluster_data[[i]]$Total_Cluster_Count) *100
}
combined_cluster_data
mean(combined_cluster_data[[1]]$Total_Cluster_Count)
mean(combined_cluster_data[[1]]$perc_HI)
mean(combined_cluster_data[[2]]$Total_Cluster_Count)
mean(na.omit(combined_cluster_data[[2]]$Total_Cluster_Count))
mean(na.omit(combined_cluster_data[[2]]$perc_HI))
mean(combined_cluster_data[[3]]$Total_Cluster_Count)
mean(combined_cluster_data[[3]]$perc_HI)
