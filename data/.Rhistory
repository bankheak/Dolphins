N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_med) + 1)))
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_large) + 1)))
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size")
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size")
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size")
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(0, 0.2)
abline(0, 0.3, lty=2)
abline(0, 0.4, lty=3)
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N_20, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
N_30[1] <- N0
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N_30, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
N_40[1] <- N0
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N_40, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
gc()
gc()
gc()
dist = matrix(c(0,5,1,8,5,0,6,3,1,6,0,9,8,3,9,0), nrow = 4, ncol = 4)
dist
1-(dist / max(dist))
install.packages('igraph', version = '1.6.0')
library(igraph) # graph_from_adjacency_matrix version = '1.6.0'
if(!require(kinship2)){install.packages('kinship2'); library(kinship2)} # genetic relatedness
if(!require(adehabitatHR)){install.packages('adehabitatHR'); library(adehabitatHR)} # Caluculate MCPs and Kernel density
## Network
if(!require(ggalt)){install.packages('ggalt'); library(ggalt)}
if(!require(network)){install.packages('network'); library(network)} # For assigning coordinates to nodes %v%
if(!require(ggmap)){install.packages('ggmap'); library(ggmap)} # register API key version = '3.0.0'
if(!require(ggraph)){install.packages('ggraph'); library(ggraph)} # For network plotting on map
if(!require(tnet)){install.packages('tnet'); library(tnet)} # For weights
if(!require(asnipe)){install.packages('asnipe'); library(asnipe)} # get_group_by_individual
if(!require(assortnet)){install.packages('assortnet'); library(assortnet)} # associative indices
source("../code/functions.R") # nxn
## Mapping
if(!require(statnet)){install.packages('statnet'); library(statnet)}
if(!require(viridis)){install.packages('viridis'); library(viridis)}
if(!require(ggnetwork)){install.packages('ggnetwork'); library(ggnetwork)} # Get cluster coords
if(!require(ggforce)){install.packages('ggforce'); library(ggforce)} # for drawing lines around social clusters
if(!require(ggOceanMaps)){install.packages('ggOceanMaps'); library(ggOceanMaps)} # To map florida
if(!require(intergraph)){install.packages('intergraph'); library(intergraph)} # To use igraph network in ggnet
if(!require(sna)){install.packages('sna'); library(sna)} # For network
if(!require(GGally)){install.packages('GGally'); library(GGally)} # For mapping networks in ggplot version = '2.2.1'
if(!require(ggplot2)){install.packages('ggplot2'); library(ggplot2)}
if(!require(sf)){install.packages('sf'); library(sf)} # Convert degrees to meters
if(!require(sp)){install.packages('sp'); library(sp)} # Convert degrees to meters
## Bayesian
if(!require(abind)){install.packages('abind'); library(abind)} # array
if(!require(brms)){install.packages('brms'); library(brms)} # For brm model
if(!require(coda)){install.packages('coda'); library(coda)}
if(!require(bayesplot)){install.packages('bayesplot'); library(bayesplot)} # plot parameters in mcmc_area
if(!require(magrittr)){install.packages('magrittr'); library(magrittr)} # For STAN
if(!require(dplyr)){install.packages('dplyr'); library(dplyr)}  # for organizing code
if(!require(rstan)){install.packages('rstan'); library(rstan)} # To make STAN run faster
if(!require(ggrepel)){install.packages('ggrepel'); library(ggrepel)} # for function labs
if(!require(RColorBrewer)){install.packages('RColorBrewer'); library(RColorBrewer)}
if(!require(gganimate)){install.packages('gganimate'); library(gganimate)}
if(!require(posterior)){install.packages('posterior'); library(posterior)} # Find the posterior sample names
if(!require(distributional)){install.packages('distributional'); library(distributional)}
if(!require(doParallel)){install.packages('doParallel'); library(doParallel)} # Faster computing
nxn <- readRDS("nxn.RData") # association matrix of list_years
# Set working directory here
setwd("../data")
nxn <- readRDS("nxn.RData") # association matrix of list_years
# Read in ig object
net <- readRDS("net.RData")
ig <- readRDS("ig.RData")
# Only show IDs of HI dolphins
HI_list <- readRDS("HI_list.RData")
HI_list <- HI_list[-4] # Get rid of natural foragers
HI_IDs <- unique(as.vector(unlist(HI_list))) # Put them all together
#----Modularity---
# igraph format with weight
el_years <- readRDS("el_years.RData")
dolphin_ig <- lapply(nxn, function (mtx)
graph_from_adjacency_matrix(as.matrix(mtx),
mode="undirected",
weighted=TRUE, diag=FALSE))
# Create an unweighted network
dolp_ig <- lapply(el_years, function (el) {
ig <- graph_from_edgelist(el[,1:2])
# Add the edge weights to this network
E(ig)$weight <- as.numeric(el[,3])
# Create undirected network
ig <- as.undirected(ig)
return(ig)
}
)
# Load all necessary packages
## Predictors
install.packages('igraph', version = '1.6.0')
library(igraph) # graph_from_adjacency_matrix version = '1.6.0'
# Create an unweighted network
dolp_ig <- lapply(el_years, function (el) {
ig <- graph_from_edgelist(el[,1:2])
# Add the edge weights to this network
E(ig)$weight <- as.numeric(el[,3])
# Create undirected network
ig <- as.undirected(ig)
return(ig)
}
)
newman <- readRDS("newman.RData")
# Generate a vector of colors based on the number of unique memberships
for (i in seq_along(dolp_ig)) {
# Generate a vector of colors based on the number of unique memberships
col <- viridis(min(max(newman[[i]]$membership), length(unique(newman[[i]]$membership))))
# Initialize the color attribute with NA
V(dolp_ig[[i]])$color <- NA
# Loop through each membership value and assign colors to corresponding vertices
for (j in 1:max(newman[[i]]$membership)){
V(dolp_ig[[i]])$color[newman[[i]]$membership == j] <- rep(col[j], sum(newman[[i]]$membership == j))
}
}
if(!require(kinship2)){install.packages('kinship2'); library(kinship2)} # genetic relatedness
if(!require(adehabitatHR)){install.packages('adehabitatHR'); library(adehabitatHR)} # Caluculate MCPs and Kernel density
## Network
if(!require(ggalt)){install.packages('ggalt'); library(ggalt)}
if(!require(network)){install.packages('network'); library(network)} # For assigning coordinates to nodes %v%
if(!require(ggmap)){install.packages('ggmap'); library(ggmap)} # register API key version = '3.0.0'
if(!require(ggraph)){install.packages('ggraph'); library(ggraph)} # For network plotting on map
if(!require(tnet)){install.packages('tnet'); library(tnet)} # For weights
if(!require(asnipe)){install.packages('asnipe'); library(asnipe)} # get_group_by_individual
if(!require(assortnet)){install.packages('assortnet'); library(assortnet)} # associative indices
source("../code/functions.R") # nxn
## Mapping
if(!require(statnet)){install.packages('statnet'); library(statnet)}
if(!require(viridis)){install.packages('viridis'); library(viridis)}
if(!require(ggnetwork)){install.packages('ggnetwork'); library(ggnetwork)} # Get cluster coords
if(!require(ggforce)){install.packages('ggforce'); library(ggforce)} # for drawing lines around social clusters
if(!require(ggOceanMaps)){install.packages('ggOceanMaps'); library(ggOceanMaps)} # To map florida
if(!require(intergraph)){install.packages('intergraph'); library(intergraph)} # To use igraph network in ggnet
if(!require(sna)){install.packages('sna'); library(sna)} # For network
if(!require(GGally)){install.packages('GGally'); library(GGally)} # For mapping networks in ggplot version = '2.2.1'
if(!require(ggplot2)){install.packages('ggplot2'); library(ggplot2)}
if(!require(sf)){install.packages('sf'); library(sf)} # Convert degrees to meters
if(!require(sp)){install.packages('sp'); library(sp)} # Convert degrees to meters
## Bayesian
if(!require(abind)){install.packages('abind'); library(abind)} # array
if(!require(brms)){install.packages('brms'); library(brms)} # For brm model
if(!require(coda)){install.packages('coda'); library(coda)}
if(!require(bayesplot)){install.packages('bayesplot'); library(bayesplot)} # plot parameters in mcmc_area
if(!require(magrittr)){install.packages('magrittr'); library(magrittr)} # For STAN
if(!require(dplyr)){install.packages('dplyr'); library(dplyr)}  # for organizing code
if(!require(rstan)){install.packages('rstan'); library(rstan)} # To make STAN run faster
if(!require(ggrepel)){install.packages('ggrepel'); library(ggrepel)} # for function labs
if(!require(RColorBrewer)){install.packages('RColorBrewer'); library(RColorBrewer)}
if(!require(gganimate)){install.packages('gganimate'); library(gganimate)}
if(!require(posterior)){install.packages('posterior'); library(posterior)} # Find the posterior sample names
if(!require(distributional)){install.packages('distributional'); library(distributional)}
if(!require(doParallel)){install.packages('doParallel'); library(doParallel)} # Faster computing
# Generate a vector of colors based on the number of unique memberships
for (i in seq_along(dolp_ig)) {
# Generate a vector of colors based on the number of unique memberships
col <- viridis(min(max(newman[[i]]$membership), length(unique(newman[[i]]$membership))))
# Initialize the color attribute with NA
V(dolp_ig[[i]])$color <- NA
# Loop through each membership value and assign colors to corresponding vertices
for (j in 1:max(newman[[i]]$membership)){
V(dolp_ig[[i]])$color[newman[[i]]$membership == j] <- rep(col[j], sum(newman[[i]]$membership == j))
}
}
centroid_list <- readRDS("centroid_list.RData")
# Define a function to convert UTM coordinates to longitude and latitude
utm_to_lonlat <- function(x, y, zone = 17, northern = TRUE) {
proj <- sprintf("+proj=utm +zone=%d %s", zone, ifelse(northern, "+north", "+south"))
xy <- data.frame(x = x, y = y)
xy <- SpatialPoints(xy, proj4string = CRS(proj))
xy <- spTransform(xy, CRS("+proj=longlat +datum=WGS84"))
return(coordinates(xy))
}
# Convert UTM coordinates to longitude and latitude
centroid_list <- lapply(centroid_list, function(df) {
lonlat <- utm_to_lonlat(df$Longitude, df$Latitude)
centroid_list <- data.frame(ID = df$ID,
X = lonlat[,1],
Y = lonlat[,2])
return(centroid_list)})
# Network without map
labeled_nodes <- list()
plot_list <- list()
# Initialize a list to store layout information for each graph
layout_list <- vector("list", length(net))
# Function to generate random layout
generate_random_layout <- function(net) {
num_nodes <- network.size(net)
layout <- matrix(runif(2 * num_nodes), ncol = 2)
return(layout)
}
# Generate random layouts for each network in the list
for (i in 1:length(net)) {
layout_list[[i]] <- generate_random_layout(net[[i]])
}
# Optionally, you can visualize the layouts to check the distribution
par(mfrow = c(1, length(net)))
for (i in 1:length(net)) {
plot.network(net[[i]], coord = layout_list[[i]], main = paste("Network", i))
}
for (i in 1:length(ig)) {  # Loop through periods
# Load in igraph
require(igraph)
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Set the network
net_i <- net[[i]]
# Unrequire igraph
#detach("package:igraph", unload=TRUE)
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Create the plot
plot <- ggnet2(net_i,
mode = combined_layout,
edge.size = get.edge.attribute(net_i, "weight"), # edge thickness
edge.color = "grey",
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
node.label = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.color = "white",
label.size = 2,
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
edge.alpha = 0.5
) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
}
for (i in 1:length(ig)) {  # Loop through periods
# Load in igraph
require(igraph)
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Set the network
net_i <- net[[i]]
# Unrequire igraph
#detach("package:igraph", unload=TRUE)
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Create the plot
plot <- ggnet2(net_i,
mode = layout_list[[2]],
edge.size = get.edge.attribute(net_i, "weight"), # edge thickness
edge.color = "grey",
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
node.label = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.color = "white",
label.size = 2,
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
edge.alpha = 0.5
) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
}
plot_list[[1]]
# Initialize a list to store layout information for each graph
layout_list <- list()
# Loop through the list of graphs and save layout information
for (i in 1:length(net)) {
layout_list[[i]] <- network.layout.fruchtermanreingold(net[[i]], NULL)
}
for (i in 1:length(ig)) {  # Loop through periods
# Load in igraph
require(igraph)
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Set network and attributes
node_color <- V(dolp_ig[[i]])$color
# Set the network
net_i <- net[[i]]
# Unrequire igraph
#detach("package:igraph", unload=TRUE)
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Create the plot
plot <- ggnet2(net_i,
mode = layout_list[[2]],
edge.size = get.edge.attribute(net_i, "weight"), # edge thickness
edge.color = "grey",
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
node.label = ifelse(labeled_nodes[[i]], net_i %v% "vertex.names", FALSE),
label.color = "white",
label.size = 2,
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
edge.alpha = 0.5
) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
}
plot_list[[1]]
# Create graph
labeled_nodes <- list()
plot_list <- list()
layout_list <- list()
# Define a custom layout function that considers groups
custom_fr_layout <- function(net, group, repulse_rad = 0.1, attract_coeff = 0.1) {
layout <- network.layout.fruchtermanreingold(net, repulse.rad = repulse_rad, attract.coeff = attract_coeff)
# Modify layout to consider groups
for (grp in unique(group)) {
idx <- which(group == grp)
centroid <- colMeans(layout[idx, , drop = FALSE])
layout[idx, ] <- sweep(layout[idx, ], 2, centroid, "+")
}
return(layout)
}
# Loop through the list of graphs and save layout information
for (i in 1:length(net)) {
# Create a dummy group for testing
group <- as.numeric(as.factor(V(net[[i]])$color))
layout_list[[i]] <- custom_fr_layout(net[[i]], group)
}
for (i in 1:length(ig)) {  # Loop through periods
# Get nodes for each behavior
labeled_nodes[[i]] <- V(ig[[i]])$name %in% HI_IDs  # Fixed index here
# Set network and attributes
node_color <- V(ig[[i]])$color
# Map the node colors to their corresponding numbers
color_mapping <- setNames(seq_along(unique(node_color)), unique(node_color))
node_color_numbers <- color_mapping[node_color]
grp <- as.vector(node_color_numbers)
# Create the plot
plot <- ggnet2(net[[i]],
mode = layout_list[[i]],
edge.size = get.edge.attribute(net[[i]], "weight"), # edge thickness
edge.color = "grey",
size = ifelse(labeled_nodes[[i]], 1.5, 0.5),
node.label = ifelse(labeled_nodes[[i]], net[[i]] %v% "vertex.names", FALSE),
label.color = "white",
label.size = 2,
node.color = ifelse(labeled_nodes[[i]], node_color, "black"),
edge.alpha = 0.5
) +
geom_encircle(
aes(x, y, group = as.factor(grp), fill = as.factor(grp)),
expand = 0.02,
alpha = 0.4) +
theme(
axis.line = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank()
) +
guides(fill = "none")  # remove legend for fill
plot_list[[i]] <- plot
}
# Define a custom layout function that considers groups
custom_fr_layout <- function(net, group, repulse_rad = 0.1, attract_coeff = 0.1) {
layout <- network.layout.fruchtermanreingold(net, repulse.rad = repulse_rad, attract.coeff = attract_coeff)
# Modify layout to consider groups
for (grp in unique(group)) {
idx <- which(group == grp)
centroid <- colMeans(layout[idx, , drop = FALSE])
layout[idx, ] <- sweep(layout[idx, ], 2, centroid, "+")
}
return(layout)
}
# Loop through the list of graphs and save layout information
for (i in 1:length(net)) {
# Create a dummy group for testing
group <- as.numeric(as.factor(V(net[[i]])$color))
layout_list[[i]] <- custom_fr_layout(net[[i]], group)
}
length(net)
i=1
as.numeric(as.factor(V(net[[i]])$color))
as.numeric(as.factor(V(ig[[i]])$color))
i=2
as.numeric(as.factor(V(ig[[i]])$color))
V(ig[[i]])$color
i=1
V(ig[[i]])$color
V(dolp_ig[[i]])$color
V(dolp_ig[[i]])$color
# Loop through the list of graphs and save layout information
for (i in 1:length(net)) {
# Create a dummy group for testing
group <- as.numeric(as.factor(V(dolp_ig[[i]])$color))
layout_list[[i]] <- custom_fr_layout(net[[i]], group)
}
group <- as.numeric(as.factor(V(dolp_ig[[i]])$color))
group
layout_list[[i]] <- custom_fr_layout(net[[i]], group)
?custom_fr_layout
??custom_fr_layout
layout_list[[i]] <- network.layout.fruchtermanreingold(net[[i]], group)
# Define a custom layout function that considers groups
custom_fr_layout <- function(net, group, repulse_rad = 0.1, attract_coeff = 0.1) {
layout <- network.layout.fruchtermanreingold(net, repulse.rad = repulse_rad, attract.coeff = attract_coeff)
# Modify layout to consider groups
for (grp in unique(group)) {
idx <- which(group == grp)
centroid <- colMeans(layout[idx, , drop = FALSE])
layout[idx, ] <- sweep(layout[idx, ], 2, centroid, "+")
}
return(layout)
}
# Loop through the list of graphs and save layout information
for (i in 1:length(net)) {
# Create a group based on the color attribute of the igraph object
group <- as.numeric(as.factor(V(dolp_ig[[i]])$color))
layout_list[[i]] <- custom_fr_layout(net[[i]], group)
}
