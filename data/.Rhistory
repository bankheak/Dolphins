line_data_split$id <- 1:nrow(line_data_split)
pot_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.CrabPots))
pot_data_split$id <- 1:nrow(pot_data_split)
# Eliminate IDs with less than 5 locations
relocate_lim <- function(df) {
ID <- unique(df$id)
obs_vect <- numeric(length(ID))
for (j in seq_along(ID)) {
obs_vect[j] <- sum(df$ID == ID[j])}
sub <- data.frame(ID = ID, obs_vect = obs_vect)
sub <- subset(sub, subset = obs_vect > 5)
df <- subset(df, ID %in% sub$ID)
}
boat_data_split <- relocate_lim(boat_data_split)
# Seperate each number of boats into their own row
boat_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.Boats))
boat_data_split$id <- 1:nrow(boat_data_split)
line_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.Lines))
line_data_split$id <- 1:nrow(line_data_split)
pot_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.CrabPots))
pot_data_split$id <- 1:nrow(pot_data_split)
# Seperate each number of boats into their own row
boat_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.Boats))
line_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.Lines))
pot_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.CrabPots))
View(line_data_split)
# Eliminate IDs with less than 5 locations
relocate_lim <- function(df) {
ID <- unique(df$SightingFID)
obs_vect <- numeric(length(ID))
for (j in seq_along(ID)) {
obs_vect[j] <- sum(df$ID == ID[j])}
sub <- data.frame(ID = ID, obs_vect = obs_vect)
sub <- subset(sub, subset = obs_vect > 5)
df <- subset(df, ID %in% sub$ID)
}
boat_data_split <- relocate_lim(boat_data_split)
line_data_split <- relocate_lim(line_data_split)
pot_data_split <- relocate_lim(pot_data_split)
# Seperate each number of boats into their own row
boat_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.Boats))
line_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.Lines))
pot_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.CrabPots))
# Eliminate IDs with less than 5 locations
relocate_lim <- function(df) {
ID <- unique(df$SightingFID)
obs_vect <- numeric(length(ID))
for (j in seq_along(ID)) {
obs_vect[j] <- sum(df$ID == ID[j])}
sub <- data.frame(ID = ID, obs_vect = obs_vect)
sub <- subset(sub, subset = obs_vect > 5)
df <- subset(df, ID %in% sub$ID)
}
ID <- unique(pot_data_split$SightingFID)
obs_vect <- numeric(length(ID))
for (j in seq_along(ID)) {
obs_vect[j] <- sum(pot_data_split$ID == ID[j])}
obs_vect
ID
obs_vect <- numeric(length(ID))
obs_vect
# Subset the data that contains human activity
human_data <- subset(sample_data, subset=c(sample_data$Year > 2012))
ID <- unique(human_data$Code)
obs_vect <- numeric(length(ID))
obs_vect
ID <- unique(pot_data_split$SightingFID)
obs_vect <- numeric(length(ID))
seq_along(ID)
# Seperate each number of boats into their own row
boat_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.Boats))
line_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.Lines))
pot_data_split <- human_data %>%
slice(rep(1:n(), times = human_data$X.CrabPots))
# Eliminate IDs with less than 5 locations
relocate_lim <- function(df) {
ID <- unique(df$SightingFID)
obs_vect <- numeric(length(ID))
for (j in seq_along(ID)) {
obs_vect[j] <- sum(df$SightingFID == ID[j])}
sub <- data.frame(ID = ID, obs_vect = obs_vect)
sub <- subset(sub, subset = obs_vect > 5)
df <- subset(df, SightingFID %in% sub$ID)
}
boat_data_split <- relocate_lim(boat_data_split)
line_data_split <- relocate_lim(line_data_split)
pot_data_split <- relocate_lim(pot_data_split)
# Make a kernel density of each human activity
create_kd <- function(df) {
## Extract IDs and coordinates
ids <- df$ID
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS and transform to UTM
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
return(kernel)
}
kernel_boat <- create_kd(boat_data_split)
# Make a kernel density of each human activity
create_kd <- function(df) {
## Extract IDs and coordinates
ids <- df$SightingFID
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS and transform to UTM
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
return(kernel)
}
kernel_boat <- create_kd(boat_data_split)
# Make a kernel density of each human activity
df <- boat_data_split
## Extract IDs and coordinates
ids <- df$SightingFID
coordinates <- df[, c("StartLon", "StartLat")]
View(coordinates)
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS and transform to UTM
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
# Calculate kernel values
kernel <- kernelUD(coords_sp_utm, h = 10000)
View(coords_sp)
coords_sp@data[["id"]]
unique(coords_sp@data[["id"]])
# Calculate kernel values
create_kd <- function(df) {
## Extract IDs and coordinates
ids <- df$Code
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS and transform to UTM
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
return(kernel)
}
homerange_kernel <- create_kd(human_data)
# Subset the data that contains human activity
human_data <- subset(sample_data, subset=c(sample_data$Year > 2012))
# Eliminate IDs with less than 5 locations
relocate_lim <- function(df) {
ID <- unique(df$Code)
obs_vect <- numeric(length(ID))
for (j in seq_along(ID)) {
obs_vect[j] <- sum(df$Code == ID[j])}
sub <- data.frame(ID = ID, obs_vect = obs_vect)
sub <- subset(sub, subset = obs_vect > 5)
df <- subset(df, Code %in% sub$ID)
}
human_data <- relocate_lim(human_data)
# Calculate kernel values
create_kd <- function(df) {
## Extract IDs and coordinates
ids <- df$Code
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS and transform to UTM
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
return(kernel)
}
homerange_kernel <- create_kd(human_data)
kernel_boat <- create_kd(boat_data_split)
create_kd <- function(df) {
## Extract IDs and coordinates
ids <- df$SightingFID
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS and transform to UTM
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
return(kernel)
}
kernel_boat <- create_kd(boat_data_split)
# Make a kernel density of each human activity
create_kd <- function(df) {
# Extract IDs and coordinates
ids <- df$SightingFID
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS to WGS84
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
# Transform to UTM
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Check if we have more than one point
if (nrow(coords_sp_utm) > 1) {
# Calculate kernel values
kernel <- kernelUD(coords_sp_utm, h = 10000)
return(kernel)
} else {
print("Error: Need more than one point to calculate kernel.")
return(NULL)
}
}
kernel_boat <- create_kd(boat_data_split)
# Check the number of unique SightingFID in boat_data_split
unique_points <- length(unique(boat_data_split$SightingFID))
print(unique_points)  # Print the count of unique points
# Print the boat_data_split to inspect the data
print(head(boat_data_split))
# Make a kernel density of each human activity
create_kd <- function(df) {
# Extract IDs and coordinates
ids <- df$SightingFID
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS to WGS84
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
# Transform to UTM
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Check if we have more than one point
if (nrow(coords_sp_utm) > 1) {
# Calculate kernel values
kernel <- kernelUD(coords_sp_utm, h = 10000)
return(kernel)
} else {
print("Error: Need more than one point to calculate kernel.")
return(NULL)
}
}
kernel_boat <- create_kd(boat_data_split)
# Make a kernel density of each human activity
create_kd <- function(df) {
# Extract IDs and coordinates
ids <- df$SightingFID
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS to UTM (Zone 17, WGS84)
proj4string(coords_sp) <- CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs")
# Check if we have more than one point
if (nrow(coords_sp) > 1) {
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
return(kernel)
} else {
print("Error: Need more than one point to calculate kernel.")
# Create an empty kernel object
empty_kernel <- list(
call = match.call(),
density = numeric(),
bandwidth = numeric(),
cov = matrix(),
grid = matrix(),
warning = "Need more than one point to calculate kernel."
)
class(empty_kernel) <- "kde"
return(empty_kernel)
}
}
kernel_boat <- create_kd(boat_data_split)
# Make a kernel density of each human activity
create_kd <- function(df) {
# Extract IDs and coordinates
ids <- df$SightingFID
coordinates <- df[, c("StartLon", "StartLat")]
# Check if we have more than one point
if (nrow(coordinates) > 1) {
# Convert to SpatialPointsDataFrame
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = df)
# Set CRS to UTM (Zone 17, WGS84)
proj4string(coords_sp) <- CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs")
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
return(kernel)
} else {
print("Error: Need more than one point to calculate kernel.")
# Return a message indicating the error
return(NULL)
}
}
kernel_boat <- create_kd(boat_data_split)
View(kernel_boat)
# Make a kernel density of each human activity
create_kd <- function(df) {
# Extract IDs and coordinates
ids <- df$SightingFID
coordinates <- df[, c("StartLon", "StartLat")]
# Check if we have more than one point
if (nrow(coordinates) > 1) {
# Create a SpatialPoints object with coordinates
coords_sp <- SpatialPoints(coordinates, proj4string = CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
return(kernel)
} else {
print("Error: Need more than one point to calculate kernel.")
# Return a message indicating the error
return(NULL)
}
}
kernel_boat <- create_kd(boat_data_split)
kernel_line <- create_kd(boat_data_split)
kernel_pot <- create_kd(boat_data_split)
?kerneloverlaphr()
# Calculate kernel overlap values
create_kov_Hactivity <- function(kernel, Hact_kern) {
kov <- kerneloverlaphr(kernel, Hact_kern, method = "HR", lev = 95)
return(kov)
}
kov_boat <- create_kov(homerange_kernel, kernel_boat)
kov_boat <- create_kov_Hactivity(homerange_kernel, kernel_boat)
# Calculate kernel overlap values
## Initialize an empty list to store the overlap results
overlap_results <- list()
## Iterate over each dolphin and calculate the overlap with boat density
for (dolphin_id in names(homerange_kernel)) {
dolphin_kernel <- homerange_kernel[[dolphin_id]]
# Calculate the overlap using kerneloverlaphr
overlap <- kerneloverlaphr(dolphin_kernel, boat_kernel, method = "HR", lev = 95)
# Store the overlap result in the list
overlap_results[[dolphin_id]] <- overlap
}
View(dolphin_kernel)
View(kernel_boat)
# Calculate kernel overlap values
## Initialize an empty list to store the overlap results
overlap_results <- list()
## Iterate over each dolphin and calculate the overlap with boat density
for (dolphin_id in names(homerange_kernel)) {
dolphin_kernel <- homerange_kernel[[dolphin_id]]
# Calculate the overlap using kerneloverlaphr
overlap <- kerneloverlaphr(dolphin_kernel, kernel_boat, method = "HR", lev = 95)
# Store the overlap result in the list
overlap_results[[dolphin_id]] <- overlap
}
View(kernel_boat)
View(homerange_kernel)
View(homerange_kernel)
# Calculate kernel overlap values
## Initialize an empty list to store the overlap results
overlap_results <- list()
## Iterate over each dolphin and calculate the overlap with boat density
for (dolphin_id in names(homerange_kernel$UD)) {
dolphin_kernel <- homerange_kernel$UD[[dolphin_id]]
# Calculate the overlap using kerneloverlaphr for Large estUDm
overlap <- kerneloverlaphr(dolphin_kernel, kernel_boat, method = "HR", lev = 95)
# Store the overlap result in the list
overlap_results[[dolphin_id]] <- overlap
}
View(dolphin_kernel)
print(homerange_kernel$UD$dolphin_id)
names(homerange_kernel$UD)
# Subset the data that contains human activity
human_data <- subset(sample_data, subset=c(sample_data$Year > 2012))
# Eliminate IDs with less than 5 locations
relocate_lim <- function(df) {
ID <- unique(df$Code)
obs_vect <- numeric(length(ID))
for (j in seq_along(ID)) {
obs_vect[j] <- sum(df$Code == ID[j])}
sub <- data.frame(ID = ID, obs_vect = obs_vect)
sub <- subset(sub, subset = obs_vect > 5)
df <- subset(df, Code %in% sub$ID)
}
human_data <- relocate_lim(human_data)
# Calculate kernel values
create_kd <- function(df) {
## Extract IDs and coordinates
ids <- df$Code
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS and transform to UTM
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp_utm, h = 10000)
# Store the kernel estimations under 'UD'
homerange_kernel <- list(UD = kernel)
return(homerange_kernel)
}
homerange_kernel <- create_kd(human_data)
View(homerange_kernel)
names(homerange_kernel$UD)
# Calculate kernel overlap values
## Initialize an empty list to store the overlap results
overlap_results <- list()
## Iterate over each dolphin and calculate the overlap with boat density
for (dolphin_id in names(homerange_kernel$UD)) {
dolphin_kernel <- homerange_kernel$UD[[dolphin_id]]
# Calculate the overlap using kerneloverlaphr for Large estUDm
overlap <- kerneloverlaphr(dolphin_kernel, kernel_boat, method = "HR", lev = 95)
# Store the overlap result in the list
overlap_results[[dolphin_id]] <- overlap
}
# Calculate kernel values
create_kd <- function(df) {
## Extract IDs and coordinates
ids <- df$Code
coordinates <- df[, c("StartLon", "StartLat")]
# Convert to data frame
ids_df <- data.frame(id = ids)
# Create a SpatialPointsDataFrame with coordinates
coords_sp <- SpatialPointsDataFrame(coords = coordinates, data = ids_df)
# Set CRS and transform to UTM
proj4string(coords_sp) <- CRS("+proj=longlat +datum=WGS84")
coords_sp_utm <- spTransform(coords_sp, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp_utm, h = 10000)
# Explicitly set the class to estUDm
class(kernel) <- "estUDm"
return(kernel)
}
homerange_kernel <- create_kd(human_data)
names(homerange_kernel$UD)
View(homerange_kernel)
homerange_kernel$UD
homerange_kernel[[1]]
View(homerange_kernel)
length(homerange_kernel)
homerange_kernel$UD[[1]]
# Calculate kernel overlap values
## Initialize an empty list to store the overlap results
overlap_results <- list()
## Iterate over each dolphin and calculate the overlap with boat density
for (dolphin_id in length(homerange_kernel)) {
dolphin_kernel <- homerange_kernel[[dolphin_id]]
# Calculate the overlap using kerneloverlaphr for Large estUDm
overlap <- kerneloverlaphr(dolphin_kernel, kernel_boat, method = "HR", lev = 95)
# Store the overlap result in the list
overlap_results[[dolphin_id]] <- overlap
}
View(kernel_boat)
# Make a kernel density of each human activity
create_kdh <- function(df) {
# Extract IDs and coordinates
ids <- df$SightingFID
coordinates <- df[, c("StartLon", "StartLat")]
# Check if we have more than one point
if (nrow(coordinates) > 1) {
# Create a SpatialPoints object with coordinates
coords_sp <- SpatialPoints(coordinates, proj4string = CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"))
# Calculate kernel values
kernel <- kernelUD(coords_sp, h = 10000)
# Explicitly set the class to estUDm
class(kernel) <- "estUDm"
return(kernel)
} else {
print("Error: Need more than one point to calculate kernel.")
# Return a message indicating the error
return(NULL)
}
}
kernel_boat <- create_kdh(boat_data_split)
kernel_line <- create_kdh(boat_data_split)
kernel_pot <- create_kdh(boat_data_split)
# Calculate kernel overlap values
## Initialize an empty list to store the overlap results
overlap_results <- list()
## Iterate over each dolphin and calculate the overlap with boat density
for (dolphin_id in length(homerange_kernel)) {
dolphin_kernel <- homerange_kernel[[dolphin_id]]
# Calculate the overlap using kerneloverlaphr for Large estUDm
overlap <- kerneloverlaphr(dolphin_kernel, kernel_boat, method = "HR", lev = 95)
# Store the overlap result in the list
overlap_results[[dolphin_id]] <- overlap
}
View(kernel_boat)
