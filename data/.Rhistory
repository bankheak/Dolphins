row_names <- lapply(matrix, function (df) {rownames(df)})
for (i in seq_along(metric)) {
metric[[i]][,1] <- row_names[[i]]
}
return(metric)
}
# Betweenness centrality
between <- lapply(el_years, function (df) {betweenness_w(df, alpha = 1)})
between_diffs <- get_names(nxn, between)
# Read in full datasheet and list (after wrangling steps)
list_years <- readRDS("list_years.RData") # (1995-2000)/(2001-2006)/(2007-2012)
nxn <- readRDS("nxn.RData") # association matrix of list_years
# Betweenness centrality
between <- lapply(el_years, function (df) {betweenness_w(df, alpha = 1)})
between_diffs <- get_names(nxn, between)
compare_between <- merge(
merge(between_diffs[[1]], between_diffs[[2]], by = "node"),
between_diffs[[3]], by = "node"
)
colnames(compare_between) <- c("ID", "Before_HAB", "During_HAB", "After_HAB")
compare_between[, c(2:4)] <- sapply(compare_between[, c(2:4)], as.numeric)
# Degree and strength centrality
strength <- lapply(el_years, function (df) {degree_w(df, measure=c("degree","output"), type="out", alpha=1)})
strength_diffs <- get_names(nxn, strength)
compare_strength <- merge(
merge(strength_diffs[[1]], strength_diffs[[2]], by = "node"),
strength_diffs[[3]], by = "node"
)
colnames(compare_strength) <- c("ID", "Before_HAB_degree", "Before_HAB_strength",
"During_HAB_degree", "During_HAB_strength",
"After_HAB_degree", "After_HAB_strength")
compare_strength[, c(2:7)] <- sapply(compare_strength[, c(2:7)], as.numeric)
# Look at all of the local metrics together
HI_data <-  subset_HI(list_years)
## Add a column containing HI type
names_BG <- lapply(HI_data, function (df) {
as.vector(unique(df$Code[df$DiffHI == "BG"]))})
names_SD <- lapply(HI_data, function (df) {
as.vector(unique(df$Code[df$DiffHI == "SD"]))})
names_FG <- lapply(HI_data, function (df) {
as.vector(unique(df$Code[df$DiffHI == "FG"]))})
### Find all of the IDs that match to make sure below works
matching_unique_ids <- list()
for (i in 1:3) {
matching_unique_ids[[i]] <- unique(c(names_BG[[i]], names_FG[[i]], names_SD[[i]]))
}
names_NF <- list()
for (i in 1:3) {
unique_codes <- unique(HI_data[[i]]$Code)
# Check for codes that are not in any of the names_BG, names_FG, names_SD
names_NF[[i]] <- unique_codes[!(unique_codes %in% names_BG[[i]] |
unique_codes %in% names_FG[[i]] |
unique_codes %in% names_SD[[i]])]}
HI_list <- list(BG = names_BG, FG = names_FG, SD = names_SD, NF = names_NF)
# Combine the data
local_metrics_HI <- data.frame(ID = compare_between$ID,
Period = c(rep("1-Before_HAB", nrow(compare_between)),
rep("2-During_HAB", nrow(compare_between)),
rep("3-After_HAB", nrow(compare_between))),
Between = c(compare_between$Before_HAB,
compare_between$During_HAB,
compare_between$After_HAB),
Degree = c(compare_strength$Before_HAB_degree,
compare_strength$During_HAB_degree,
compare_strength$After_HAB_degree),
Strength = c(compare_strength$Before_HAB_strength,
compare_strength$During_HAB_strength,
compare_strength$After_HAB_strength))
# Add HI_type column
local_metrics_HI_1 <- local_metrics_HI[local_metrics_HI$Period == "1-Before_HAB", ]
local_metrics_HI_2 <- local_metrics_HI[local_metrics_HI$Period == "2-During_HAB", ]
local_metrics_HI_3 <- local_metrics_HI[local_metrics_HI$Period == "3-After_HAB", ]
local_list <- list(local_metrics_HI_1, local_metrics_HI_2, local_metrics_HI_3)
## Initialize a new dataframe to store the results
result_df <- data.frame()
## Initialize a counter
counter <- 1
for (p in 1:3) {
for (i in HI_list) {
index <- local_list[[p]]$ID %in% i[[p]]
# Create a new row for each ID that falls into four categories
new_rows <- local_list[[p]][index, ]
new_rows$HI <- names(HI_list[counter])
# Increment the counter
counter <- counter + 1
# Append the new rows to the result dataframe
result_df_new <- rbind(result_df, new_rows)
}
result_df <- rbind(result_df, result_df_new)
}
result_df
View(result_df)
names(HI_list[counter])
View(HI_list)
names(HI_list)
names(HI_list[1])
names(HI_list[2])
i=HI_list[[2]]
p=2
counter=2
index <- local_list[[p]]$ID %in% i[[p]]
index
# Create a new row for each ID that falls into four categories
new_rows <- local_list[[p]][index, ]
new_rows
new_rows$HI <- names(HI_list[counter])
new_rows
## Initialize a new dataframe to store the results
result_df <- data.frame()
## Initialize a counter
counter <- 1
p=1
for (i in HI_list) {
index <- local_list[[p]]$ID %in% i[[p]]
# Create a new row for each ID that falls into four categories
new_rows <- local_list[[p]][index, ]
new_rows$HI <- names(HI_list[counter])
# Increment the counter
counter <- counter + 1
# Append the new rows to the result dataframe
result_df_new <- rbind(result_df, new_rows)
}
result_df_new
local_list
View(local_list)
View(local_list[[1]])
i in HI_list
for (i in HI_list)
## Initialize a new dataframe to store the results
result_df <- data.frame()
## Initialize a counter
counter <- 1
for (p in 1:3) {
result_df_new <- data.frame()
for (i in HI_list) {
index <- local_list[[p]]$ID %in% i[[p]]
# Create a new row for each ID that falls into four categories
new_rows <- local_list[[p]][index, ]
new_rows$HI <- names(HI_list[counter])
# Increment the counter
counter <- counter + 1
# Append the new rows to the result dataframe
result_df_new <- rbind(result_df, new_rows)
}
result_df <- rbind(result_df, result_df_new)
}
View(result_df)
View(names_BG)
p=2
i=HI_list[[1]]
index <- local_list[[p]]$ID %in% i[[p]]
index
# Create a new row for each ID that falls into four categories
new_rows <- local_list[[p]][index, ]
new_rows
## Initialize a counter
counter <- 1
new_rows$HI <- names(HI_list[counter])
new_rows
## Initialize a new dataframe to store the results
result_df <- data.frame()
result_df_new <- data.frame()
for (i in HI_list) {
index <- local_list[[p]]$ID %in% i[[p]]
# Create a new row for each ID that falls into four categories
new_rows <- local_list[[p]][index, ]
new_rows$HI <- names(HI_list[counter])
# Increment the counter
counter <- counter + 1
# Append the new rows to the result dataframe
result_df_new <- rbind(result_df, new_rows)
}
result_df_new
counter
i
View(i)
View(HI_list)
## Initialize a new dataframe to store the results
result_df <- data.frame()
## Initialize a counter
for (p in 1:3) {
counter <- 1
result_df_new <- data.frame()
for (i in HI_list) {
index <- local_list[[p]]$ID %in% i[[p]]
# Create a new row for each ID that falls into four categories
new_rows <- local_list[[p]][index, ]
new_rows$HI <- names(HI_list[counter])
# Increment the counter
counter <- counter + 1
# Append the new rows to the result dataframe
result_df_new <- rbind(result_df, new_rows)
}
result_df <- rbind(result_df, result_df_new)
}
View(result_df)
## Initialize a new dataframe to store the results
result_df <- data.frame()
## Initialize a counter
for (p in 1:3) {
counter <- 0
result_df_new <- data.frame()
for (i in HI_list) {
# Increment the counter
counter <- counter + 1
index <- local_list[[p]]$ID %in% i[[p]]
# Create a new row for each ID that falls into four categories
new_rows <- local_list[[p]][index, ]
new_rows$HI <- names(HI_list[counter])
# Append the new rows to the result dataframe
result_df_new <- rbind(result_df, new_rows)
}
result_df <- rbind(result_df, result_df_new)
}
View(result_df)
counter
## Initialize a new dataframe to store the results
result_df <- data.frame()
## Initialize a counter
for (p in 1:3) {
counter <- 0
result_df_new <- data.frame()
for (i in HI_list) {
# Increment the counter
counter <- counter + 1
index <- local_list[[p]]$ID %in% i[[p]]
# Create a new row for each ID that falls into four categories
new_rows <- local_list[[p]][index, ]
new_rows$HI <- names(HI_list[counter])
# Append the new rows to the result dataframe
result_df_new <- rbind(result_df_new, new_rows)
}
result_df <- rbind(result_df, result_df_new)
}
View(result_df)
# Make period a binary variable and HI a factorial
result_df$During <- ifelse(result_df$Period == "2-During_HAB", 1, 0)
result_df$After <- ifelse(result_df$Period == "3-After_HAB", 1, 0)
result_df$HI <- as.factor(result_df$HI)
# Save dataset
saveRDS(result_df, "result_df.RData")
## Between
ggplot(result_df, aes(x = Period, y = Between, fill = HI)) +
geom_boxplot()
## Strength
ggplot(result_df, aes(x = Period, y = Strength, fill = HI)) +
geom_boxplot()
## Degree
ggplot(result_df, aes(x = Period, y = Degree, fill = HI)) +
geom_boxplot()
# Check distributions
hist(c(scale(result_df$Between))) # continuous
hist(c(scale(result_df$Degree)))
hist(c(scale(result_df$Strength)))
# Check distributions
hist(c(scale(result_df$Between))) # continuous
# Check distributions
hist(result_df$Between) # continuous
hist(result_df$Degree)
hist(result_df$Strength)
# Check distributions
hist(result_df$Between) # continuous
# Make dummy variables
result_df$BG <- ifelse(result_df$HI == "BG", 1, 0)
result_df$FG <- ifelse(result_df$HI == "FG", 1, 0)
result_df$SD <- ifelse(result_df$HI == "SD", 1, 0)
# Look into nodal regression
## HI Behavior Combined Two Year Period ##
fit_mcmc.b <- MCMCglmm(Between ~ BG * Period + FG * Period + SD, data = result_df, nitt = 10000)
summary(fit_mcmc.b) # Might need to use a negative binomial dist
fit_mcmc.s <- MCMCglmm(Strength ~ BG * Period + FG * Period + SD, data = result_df, nitt = 10000)
summary(fit_mcmc.s)
fit_mcmc.d <- MCMCglmm(Degree ~ BG * Period + FG * Period + SD, data = result_df, nitt = 10000)
summary(fit_mcmc.d)
?MCMCglmm
View(result_df)
# Look into nodal regression
## HI Behavior Combined Two Year Period ##
fit_mcmc.b <- MCMCglmm(Between ~ BG * During + FG * During + SD * During
BG * After + FG * After + SD * After, data = result_df, nitt = 10000)
# Look into nodal regression
## HI Behavior Combined Two Year Period ##
fit_mcmc.b <- MCMCglmm(Between ~ BG * During + FG * During + SD * During +
BG * After + FG * After + SD * After, data = result_df, nitt = 10000)
summary(fit_mcmc.b) # Might need to use a negative binomial dist
fit_mcmc.s <- MCMCglmm(Strength ~ BG * During + FG * During + SD * During +
BG * After + FG * After + SD * After, data = result_df, nitt = 10000)
summary(fit_mcmc.s)
fit_mcmc.d <- MCMCglmm(Degree ~ BG * During + FG * During + SD * During +
BG * After + FG * After + SD * After, data = result_df, nitt = 10000)
summary(fit_mcmc.d)
# Check for model convergence
model <- fit_mcmc.s
plot(model$Sol)
plot(model$VCV)
# Extract Posteriors
posterior <- model$Sol
# Plot the posterior distribution
mcmc_intervals(posterior, pars = c("(Intercept)", "BG", "FG", "SD",
"During", "After", "BG:During", "FG:During", "SD:During",
"BG:After", "FG:After", "SD:After"))
# Plot the posterior distribution
mcmc_intervals(posterior, pars = c("(Intercept)", "BG", "FG", "SD",
"During", "After", "BG:During", "During:FG", "During:SD",
"BG:After", "FG:After", "SD:After"))
mcmc_areas(
posterior,
pars = c("(Intercept)", "BG", "FG", "SD",
"During", "After", "BG:During", "During:FG", "During:SD",
"BG:After", "FG:After", "SD:After"),
prob = 0.8, # 80% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
)
# Plot the posterior distribution
mcmc_intervals(posterior, pars = c("(Intercept)", "BG", "FG", "SD",
"During", "After", "BG:During", "During:FG", "During:SD",
"BG:After", "FG:After", "SD:After"))
# Check distributions
hist(result_df$Between) # continuous
hist(result_df$Degree)
hist(result_df$Strength)
# Extract specific columns from each data frame in list_years
aux_data <- function(list_years) {
aux <- lapply(list_years, function(df) {
data.frame(Code = df$Code,
Behaviors = df$Behaviors,
HumanInteraction = df$HumanInteraction,
ConfHI = df$ConfHI)})
# Add the 'Foraging' variable to each data frame in the 'aux' list
aux <- lapply(aux, function(df) {
df$Foraging <- "Other"
df$Foraging[grepl(pattern = 'Feed', x = df$Behaviors, ignore.case = FALSE)] <- "Feed"
df
})
return(aux)
}
aux <- aux_data(list_years)
# Categorize ID to Sightings
ID_sight <- function(aux_data) {
IDbehav <- lapply(aux_data, function(df) {
df <- data.frame(
Code = unique(df$Code),
Sightings = tapply(df$Code, df$Code, length)
)
df
})
return(IDbehav)
}
IDbehav <- ID_sight(aux)
# Separate HI Behaviors
#' BG = Beg: F, G
#' SD = Scavenge and Depredation: A, B, C, D, E
#' FG = Fixed Gear Interaction: P
# Change the code using ifelse statements
subset_HI <- function(aux_data) {
for (i in seq_along(aux_data)) {
aux_data[[i]]$DiffHI <- ifelse(aux_data[[i]]$ConfHI %in% c("F", "G"), "BG",
ifelse(aux_data[[i]]$ConfHI %in% c("A", "B", "C", "D", "E"), "SD",
ifelse(aux_data[[i]]$ConfHI %in% c("P"), "FG", "None")))
}
return(aux_data)  # Return the modified list of data frames
}
aux <- subset_HI(aux)
# Clump all the HI behaviors together
clump_behav <- function(aux_data) {
for (i in seq_along(aux_data)) {
aux_data[[i]]$DiffHI <- ifelse(aux_data[[i]]$DiffHI != "None", 1, 0)}
# Categorize DiffHI to IDs
rawHI <- lapply(aux_data, function(df) {
# Sum up the frequencies of HI by code
aggregated_df <- aggregate(DiffHI ~ Code, data = df, sum)
unique_codes_df <- data.frame(Code = unique(df$Code))
# Merge the unique codes data frame with the aggregated data frame
merged_df <- merge(unique_codes_df, aggregated_df, by = "Code", all.x = TRUE)
# Fill missing Freq values (if any) with 0
merged_df$DiffHI[is.na(merged_df$DiffHI)] <- 0
return(merged_df)
})
return(rawHI)
}
rawHI <- clump_behav(aux)
# Get total number of HI individuals
total_HI_IDs <- unique(unlist(lapply(rawHI, function (df) unique(df$Code[df$ConfHI > 0]))))
# Get HI Freq
create_IDbehav_HI <- function(IDbehav_data, rawHI_data){
IDbehav_HI <- lapply(seq_along(IDbehav_data), function(i) {
df <- IDbehav_data[[i]]
df$HI <- rawHI_data[[i]]$DiffHI
colnames(df) <- c("Code", "Sightings", "HI")
df
})
return(IDbehav_HI)
}
IDbehav_HI <- create_IDbehav_HI(IDbehav, rawHI)
# Proportion of Sightings spent in HI
Prop_HI <- function(IDbehav) {
lapply(seq_along(IDbehav), function(i) {
df <- IDbehav[[i]]
df$HIprop <- as.numeric(df$HI) / as.numeric(df$Sightings)
df$HIprop[is.na(df$HIprop)] <- 0
# Keep only 'Code' and 'HIprop' columns
df <- df[, c('Code', 'HIprop')]
df
})
}
prob_HI <- Prop_HI(IDbehav_HI)
# Dissimilarity of HI proportion among individual dolphins, using Euclidean distance
dis_matr <- function(Prop_HI, nxn) {
# Order data
order_rows <- rownames(nxn[[1]])
# Apply the order to each matrix in the list
Prop_HI <- lapply(Prop_HI, function (df) {
df$Code <- df$Code[match(order_rows, df$Code)]
return(df)})
# Create matrix
dissimilarity_HI <- list()
for (i in seq_along(Prop_HI)) {
fake_HIprop <- Prop_HI[[i]]$HIprop
dissimilarity_HI[[i]] <- as.matrix(dist(matrix(fake_HIprop), method = "euclidean"))
}
return(dissimilarity_HI)
}
dist_HI <- dis_matr(prob_HI, nxn)
# Check for model convergence
model <- fit_mcmc.d
# Extract Posteriors
posterior <- model$Sol
# Plot the posterior distribution
mcmc_intervals(posterior, pars = c("(Intercept)", "BG", "FG", "SD",
"During", "After", "BG:During", "During:FG", "During:SD",
"BG:After", "FG:After", "SD:After"))
# Check distributions
hist(result_df$Between) # continuous
?MCMCglmm
# Look into nodal regression
## HI Behavior Combined Two Year Period ##
fit_mcmc.b <- MCMCglmm(Between ~ BG * During + FG * During + SD * During +
BG * After + FG * After + SD * After, data = result_df, nitt = 10000, family = "nzbinom")
# Look into nodal regression
## HI Behavior Combined Two Year Period ##
fit_mcmc.b <- MCMCglmm(Between ~ BG * During + FG * During + SD * During +
BG * After + FG * After + SD * After, data = result_df, nitt = 10000, family = "poisson")
# Check distributions
hist(result_df$Between) # continuous
## Between
ggplot(result_df, aes(x = Period, y = Between, fill = HI)) +
geom_boxplot()
library(igraph) # Measure centrality here
# Read in sex and age data
ILV <- read.csv("Paternity_data.csv")
ILV
# Subset paternity data
pedigree_df <- ILV[!duplicated(ILV[, "Alias"]), c("Alias", "Mom", "Dad", "Sex")]
# Fix dad data
pedigree_df$Dad <- ifelse(pedigree_df$Dad == "na", NA, pedigree_df$Dad)
pedigree_df$Dad <- ifelse(pedigree_df$Dad == "FB26 or FB66", "FB26", pedigree_df$Dad)
pedigree_df$Dad <- ifelse(pedigree_df$Dad == "FB76 or FB38", "FB76", pedigree_df$Dad)
# Fix sex so that probable is assigned
pedigree_df$Sex <- ifelse(ILV$Sex == "Probable Female", "Female",
ifelse(ILV$Sex == "Probable Male", "Male", ILV$Sex))
pedigree_df
pedigree_df
pedigree_df
pedigree_df
# Fix sex so that probable is assigned
pedigree_df$Sex <- ifelse(ILV$Sex == "Probable Female", "Female",
ifelse(ILV$Sex == "Probable Male", "Male", ILV$Sex))
# Make sex numeric
pedigree_df$Sex <- ifelse(pedigree_df$Sex == "Female", 2,
ifelse(pedigree_df$Sex == "Male", 1, NA))
# Make id numeric
pedigree_df$ID <- rownames(pedigree_df)
## Moms
for (i in 1:nrow(pedigree_df)) {
pedigree_df$Mom <- ifelse(pedigree_df$Mom %in% pedigree_df$Alias[i],
pedigree_df$ID[i], pedigree_df$Mom)
}
pedigree_df$Mom <- ifelse(nchar(pedigree_df$Mom) > 3, NA, pedigree_df$Mom)
### Fill in the rest of the NAs with random numbers
start_value <- 118
for (i in 1:nrow(pedigree_df)) {
if (is.na(pedigree_df$Mom[i])) {
pedigree_df$Mom[i] <- start_value
start_value <- start_value + 1
}
}
## Dads
for (i in 1:nrow(pedigree_df)) {
pedigree_df$Dad <- ifelse(pedigree_df$Dad %in% pedigree_df$Alias[i],
pedigree_df$ID[i], pedigree_df$Dad)
}
pedigree_df$Dad <- ifelse(nchar(pedigree_df$Dad) > 3, NA, pedigree_df$Dad)
### Fill in the rest of the NAs with random numbers
start_value <- 118
for (i in 1:nrow(pedigree_df)) {
if (is.na(pedigree_df$Dad[i])) {
pedigree_df$Dad[i] <- start_value
start_value <- start_value + 1
}
}
# Now create data for function
pedigree_data <- data.frame(id = pedigree_df$ID,
mom = pedigree_df$Mom,
dad = pedigree_df$Dad,
sex = pedigree_df$Sex)
pedigree_data
kin_matrix <- kinship(id = pedigree_data$Alias,
dadid = pedigree_data$Dad,
momid = pedigree_data$Mom,
sex = pedigree_data$Sex)
tped <- with(pedigree_data, pedigree(id, dad, mom, sex))
