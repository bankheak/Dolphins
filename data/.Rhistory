knitr::opts_chunk$set(echo = TRUE)
#maximum intrinsic growth rate
r <- 0.3
# carrying capacity
K <- 500
# initial population size
N0 <- 5
numyears <- 50
N <- rep(NA, numyears) #makes an empty vector (NA) with length numyears. This is an easy way to make an object to fill
N[1] <- N0 #initialize the vector for the first year
for(t in 1:(numyears-1)){  #Note the indexing from 1 to (numyears-1) so that the last element in the vector is N[numyears] and not N[numyears+1], which is bigger than the vector we made
N[t+1] <- N[t] + r * N[t]*(1 - N[t]/K) #Use the appropriate equation
}
# Plot through time
plot(1:numyears, N)
N_t <- N[1:49]
N_t1 <- N[2:50]
plot(N_t, N_t1)
knitr::opts_chunk$set(echo = TRUE)
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N_20, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
N_30[1] <- N0
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N_30, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
N_40[1] <- N0
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N_40, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
################################
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
################################
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
################################
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size")
lines(1:numyears, N_med)
lines(1:numyears, N_large)
r <- 0.3
K <- 500
N0 <- 500
################################
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
################################
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
################################
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size")
lines(1:numyears, N_med)
lines(1:numyears, N_large)
################################
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
################################
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
################################
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_small, col = "blue", lyt = 1, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
lines(1:numyears, N_med, col = "red", lyt = 2)
lines(1:numyears, N_large, col = "green", lyt = 3)
knitr::opts_chunk$set(echo = TRUE)
#' The max of logistic growth curve is r*K/4,
#' which can be found by plugging in K/2 for N in rN (1 - N/K)
r = 0.6
K = 500
N = K/2
MSY = r * N * (1 - N/K)
MSY
knitr::opts_chunk$set(echo = TRUE)
# Find/compare pre-breeding eigenvector
pre_turtle_proportions <- proportions(turtle_pops, 2)
turtle_int_pop <- c(16, # 16 newborns
0, # no 1-year olds
0, # no 2-year olds
0, # no 3-year olds
4) # 4 adults
ann_surv <- data.frame(new = 0.5, one = 0.75,
two = 0.75, three = 0.75,
adult = 0.8)
fecund <- 4
# Adults and subadults can reproduce
## Adults
ann_surv$adult * fecund
## Subadults
ann_surv$three * fecund
turtle_trans_mat <- matrix(0, 5, 5)
turtle_trans_mat[2, 1] <- ann_surv$new
turtle_trans_mat[3, 2] <- ann_surv$one
turtle_trans_mat[4, 3] <- ann_surv$two
turtle_trans_mat[5, 4] <- ann_surv$three
turtle_trans_mat[5, 5] <- ann_surv$adult
turtle_trans_mat[1, 4] <- ann_surv$three * fecund
turtle_trans_mat[1, 5] <- ann_surv$adult * fecund
colnames(turtle_trans_mat) <- c("Newborn", "1-Year", "2-Year", "3-Year", "Adult")
rownames(turtle_trans_mat) <- c("Newborn", "1-Year", "2-Year", "3-Year", "Adult")
turtle_trans_mat
turtle_pops <- matrix(0, 5, 31)
turtle_pops[,1] <- turtle_int_pop
for (i in 1:30) {
turtle_pops[ , i + 1] <- turtle_trans_mat %*% turtle_pops[ , i]
}
total_annual_N <- colSums(turtle_pops)
N_t <- total_annual_N[1:30]
N_t1 <- total_annual_N[2:31]
lambda <- N_t1/N_t
# for loop method
prop_age <- matrix(0, 5, 31)
for (i in 1:31) {
prop_age[, i] <- turtle_pops[, i]/total_annual_N[i]
}
# proportions
prop_age <- proportions(turtle_pops, 2)
# Graphs through time
time <- 1:31
## Total N
plot(time, total_annual_N, ylab = "Total Population", xlab = "Time (years)")
## Lambda
time <- 1:30
plot(time, lambda, ylab = "Lambda", xlab = "Time (years)")
## Proportions
time <- 1:31
plot(time, prop_age[1,], col = "blue", ylim = c(0,1), ylab = "Proportion of Age Groups", xlab = "Time (years)")
lines(time, prop_age[2,], col = "red")
lines(time, prop_age[3,], col = "green")
lines(time, prop_age[4,], col = "orange")
lines(time, prop_age[5,], col = "pink")
legend(24, 1, legend = c("Newborn", "1-Year", "2-Year", "3-Year", "Adult"), col = c("blue",
"red", "green", "orange", "pink"), title = "Ages", cex = 0.75)
final_lambda <- lambda[30]
stable_age_dist <- prop_age[,31]
# Change starting pop
turtle_int_pop <- c(5, 5, 5, 5, 5)
# Matrix multiplication with transition matrix
turtle_pops <- matrix(0, 5, 31)
turtle_pops[,1] <- turtle_int_pop
for (i in 1:30) {
turtle_pops[ , i + 1] <- turtle_trans_mat %*% turtle_pops[ , i]
}
# Lambda
total_annual_N <- colSums(turtle_pops)
N_t <- total_annual_N[1:30]
N_t1 <- total_annual_N[2:31]
lambda <- N_t1/N_t
# Proportions
prop_age <- proportions(turtle_pops, 2)
# Final lambda and props
final_lambda_2 <- lambda[30]
stable_age_dist_2 <- prop_age[,31]
# Compare
final_lambda
final_lambda_2
## The same
stable_age_dist
stable_age_dist_2
## The same
# Initial pop
turtle_int_pop <- c(16, # 16 newborns
0, # no 1-year olds
0, # no 2-year olds
0, # no 3-year olds
4) # 4 adults
# Change transition matrix
ann_surv <- data.frame(new = 0.5 * 0.10, one = 0.75,
two = 0.75, three = 0.75,
adult = 0.8)
turtle_trans_mat[2, 1] <- ann_surv$new
# Simulate population
turtle_pops <- matrix(0, 5, 31)
turtle_pops[,1] <- turtle_int_pop
for (i in 1:30) {
turtle_pops[ , i + 1] <- turtle_trans_mat %*% turtle_pops[ , i]
}
# Lambda
total_annual_N <- colSums(turtle_pops)
N_t <- total_annual_N[1:30]
N_t1 <- total_annual_N[2:31]
lambda <- N_t1/N_t
final_lambda_3 <- lambda[30]
# Change
final_lambda
final_lambda_3
## It changes to a decreasing population (< 1)
# Change transition matrix
ann_surv <- data.frame(new = 0.5 * 0.10, one = 0.75,
two = 0.75, three = 0.75,
adult = 0.95)
turtle_trans_mat[5, 5] <- ann_surv$adult
turtle_trans_mat[1, 5] <- ann_surv$adult * fecund
# Simulate population
turtle_pops <- matrix(0, 5, 31)
turtle_pops[,1] <- turtle_int_pop
for (i in 1:30) {
turtle_pops[ , i + 1] <- turtle_trans_mat %*% turtle_pops[ , i]
}
# Total pop per year
total_annual_N <- colSums(turtle_pops)
# Lambda
N_t <- total_annual_N[1:30]
N_t1 <- total_annual_N[2:31]
lambda <- N_t1/N_t
# Proportions
prop_age <- proportions(turtle_pops, 2)
# Final lambda and props
final_lambda_4 <- lambda[30]
stable_age_dist_4 <- prop_age[,31]
final_lambda_4
stable_age_dist_4
## Total N
plot(time, total_annual_N, ylab = "Total Population", xlab = "Time (years)")
final_lambda_4
stable_age_dist_4[5]
((0.95/0.8) - 1) * 100 # The percent increase of the survival rate
# Change adult survival
as <- 0.916
# Change transition matrix
ann_surv <- data.frame(new = 0.5 * 0.10, one = 0.75,
two = 0.75, three = 0.75,
adult = as)
turtle_trans_mat[5, 5] <- ann_surv$adult
turtle_trans_mat[1, 5] <- ann_surv$adult * fecund
# Simulate population
turtle_pops <- matrix(0, 5, 31)
turtle_pops[,1] <- turtle_int_pop
for (i in 1:30) {
turtle_pops[ , i + 1] <- turtle_trans_mat %*% turtle_pops[ , i]
}
# Total pop per year
total_annual_N <- colSums(turtle_pops)
# Lambda
N_t <- total_annual_N[1:30]
N_t1 <- total_annual_N[2:31]
lambda <- N_t1/N_t
# Final lambda and props
final_lambda_5 <- lambda[30]
final_lambda_5
((as/0.8) - 1) * 100 # The percent increase of the survival rate
# Change transition matrix
ann_surv <- data.frame(new = 0.5 * 0.10, one = 0.75,
two = 0.75, three = 0.75,
adult = 0.8)
turtle_trans_mat[5, 5] <- ann_surv$adult
turtle_trans_mat[1, 4] <- ann_surv$three * fecund
turtle_trans_mat[1, 5] <- ann_surv$adult * fecund
fecund <- 10
# Simulate population
turtle_pops <- matrix(0, 5, 31)
turtle_pops[,1] <- turtle_int_pop
for (i in 1:30) {
turtle_pops[ , i + 1] <- turtle_trans_mat %*% turtle_pops[ , i]
}
# Total pop per year
total_annual_N <- colSums(turtle_pops)
# Lambda
N_t <- total_annual_N[1:30]
N_t1 <- total_annual_N[2:31]
lambda <- N_t1/N_t
# Final lambda and props
final_lambda_6 <- lambda[30]
final_lambda_3
final_lambda_6
## Went to positive growth
((final_lambda_6/final_lambda_3) - 1) * 100 # The percent increase of the survival rate
# Initial pop
turtle_int_pop <- c(0, # no 1-year olds
0, # no 2-year olds
0, # no 3-year olds
4) # 4 adults
# Survival and Fecundity
ann_surv <- data.frame(one = 0.75,
two = 0.75, three = 0.75,
adult = 0.8)
fecund <- 4
# Transition Matrix
turtle_trans_mat_pre <- matrix(0, 4, 4)
turtle_trans_mat_pre[2, 1] <- ann_surv$one
turtle_trans_mat_pre[3, 2] <- ann_surv$two
turtle_trans_mat_pre[4, 3] <- ann_surv$three
turtle_trans_mat_pre[4, 4] <- ann_surv$adult
turtle_trans_mat_pre[1, 3] <- ann_surv$three * fecund
turtle_trans_mat_pre[1, 4] <- ann_surv$adult * fecund
colnames(turtle_trans_mat_pre) <- c("1-Year", "2-Year", "3-Year", "Adult")
rownames(turtle_trans_mat_pre) <- c("1-Year", "2-Year", "3-Year", "Adult")
turtle_trans_mat_pre
# Simulate population
turtle_pops <- matrix(0, 4, 31)
turtle_pops[,1] <- turtle_int_pop
for (i in 1:30) {
turtle_pops[ , i + 1] <- turtle_trans_mat_pre %*% turtle_pops[ , i]
}
# Total pop per year
total_annual_N <- colSums(turtle_pops)
# Lambda
N_t <- total_annual_N[1:30]
N_t1 <- total_annual_N[2:31]
lambda <- N_t1/N_t
# Final lambda and props
final_lambda_7 <- lambda[30]
final_lambda
final_lambda_7
# The lambda for the pre-breeding model is a lot higher than the lambda for the post-breeding model.
# Change post-breeding transition matrix
ann_surv <- data.frame(new = 0.5, one = 0.75,
two = 0.75, three = 0.75,
adult = 0.8)
turtle_trans_mat[2, 1] <- ann_surv$new
# Calculate eigenvalue
eigen(turtle_trans_mat)$values[1]
eigen(turtle_trans_mat_pre)$values[1]
## They are the same as the lambda
# Find/compare pre-breeding eigenvector
pre_turtle_proportions <- proportions(turtle_pops, 2)
pre_stable_age <- eigen(turtle_trans_mat_pre)$vectors[,1]/sum(eigen(turtle_trans_mat_pre)$vectors[,1])
pre_stable_age #The pre-breeding model eigenvector
prop_age[, 31]
# Set working directory here
setwd("../data")
# Set working directory here
setwd("../data")
setwd("C:/Users/bankh/My_Repos/Dolphins/code")
# Set working directory here
setwd("../data")
# Read in social association matrix and listed data
sim_HI <- readRDS("sim_HI.RData") # HI Sim Matrix
ILV_mat <-readRDS("ILV_mat.RData") # Age and Sex Matrices
kov <- readRDS("kov.RDS")  # Home range overlap
nxn <- readRDS("nxn.RData") # Association Matrix
# Prepare random effect for MCMC
num_nodes <- lapply(nxn, function(df) dim(df)[1])
node_names <- lapply(nxn, function(df) colnames(df))
# Separate IDs into i and j
node_ids_i <- lapply(num_nodes, function(df) matrix(rep(1:df, each = df), nrow = df, ncol = df))
node_ids_j <- lapply(node_ids_i, function(df) t(df))
# Format data
upper_tri <- lapply(nxn, function(df) upper.tri(df, diag = FALSE))
edge_nxn <- abind(lapply(nxn, function(mat) mat[upper.tri(mat, diag = FALSE)]), along = 2)
## Split by 3 for int data
HAB_data <- as.data.frame(cbind(c(edge_nxn[,1], edge_nxn[,2], edge_nxn[,3]), c(rep(1, nrow(edge_nxn)), rep(2, nrow(edge_nxn)), rep(3, nrow(edge_nxn)))))
colnames(HAB_data) <- c("SRI", "HAB")
HAB_data$During <- ifelse(HAB_data$HAB == 2, 1, 0)
HAB_data$After <- ifelse(HAB_data$HAB == 3, 1, 0)
HI <- abind(lapply(sim_HI, function(mat) mat[upper.tri(mat, diag = FALSE)]), along = 2)
one <- lapply(seq_along(node_ids_i), function(i) factor(as.vector(node_names[[i]][node_ids_i[[i]][upper_tri[[i]]]]), levels = node_names[[i]]))
two <- lapply(seq_along(node_ids_j), function(i) factor(as.vector(node_names[[i]][node_ids_j[[i]][upper_tri[[i]]]]), levels = node_names[[i]]))
# Put data into a dataframe
df_list = data.frame(edge_weight = HAB_data[, 1],
HAB_During = HAB_data[, 3],
HAB_After = HAB_data[, 4],
HRO = unlist(lapply(kov, function (df) df[upper.tri(df, diag = FALSE)])),
sex_similarity = rep(ILV_mat[[1]][upper.tri(ILV_mat[[1]], diag = FALSE)], 3),
age_similarity = rep(ILV_mat[[2]][upper.tri(ILV_mat[[2]], diag = FALSE)], 3),
#GR = rep(gr[upper.tri(gr, diag = FALSE)], 3),
HI_similarity = c(HI[,c(1:3)]),
node_id_1 = unlist(one),
node_id_2 = unlist(two))
## Split by 3 for int data
HAB_data <- as.data.frame(cbind(c(edge_nxn[,1], edge_nxn[,2], edge_nxn[,3]), c(rep(1, nrow(edge_nxn)), rep(2, nrow(edge_nxn)), rep(3, nrow(edge_nxn)))))
# Read in social association matrix and listed data
sim_HI <- readRDS("sim_HI.RData") # HI Sim Matrix
ILV_mat <-readRDS("ILV_mat.RData") # Age and Sex Matrices
kov <- readRDS("kov.RDS")  # Home range overlap
nxn <- readRDS("nxn.RData") # Association Matrix
# Prepare random effect for MCMC
num_nodes <- lapply(nxn, function(df) dim(df)[1])
node_names <- lapply(nxn, function(df) colnames(df))
# Separate IDs into i and j
node_ids_i <- lapply(num_nodes, function(df) matrix(rep(1:df, each = df), nrow = df, ncol = df))
node_ids_j <- lapply(node_ids_i, function(df) t(df))
# Format data
upper_tri <- lapply(nxn, function(df) upper.tri(df, diag = FALSE))
library(abind) # array
edge_nxn <- abind(lapply(nxn, function(mat) mat[upper.tri(mat, diag = FALSE)]), along = 2)
## Split by 3 for int data
HAB_data <- as.data.frame(cbind(c(edge_nxn[,1], edge_nxn[,2], edge_nxn[,3]), c(rep(1, nrow(edge_nxn)), rep(2, nrow(edge_nxn)), rep(3, nrow(edge_nxn)))))
colnames(HAB_data) <- c("SRI", "HAB")
HAB_data$During <- ifelse(HAB_data$HAB == 2, 1, 0)
HAB_data$After <- ifelse(HAB_data$HAB == 3, 1, 0)
HI <- abind(lapply(sim_HI, function(mat) mat[upper.tri(mat, diag = FALSE)]), along = 2)
one <- lapply(seq_along(node_ids_i), function(i) factor(as.vector(node_names[[i]][node_ids_i[[i]][upper_tri[[i]]]]), levels = node_names[[i]]))
two <- lapply(seq_along(node_ids_j), function(i) factor(as.vector(node_names[[i]][node_ids_j[[i]][upper_tri[[i]]]]), levels = node_names[[i]]))
# Put data into a dataframe
df_list = data.frame(edge_weight = HAB_data[, 1],
HAB_During = HAB_data[, 3],
HAB_After = HAB_data[, 4],
HRO = unlist(lapply(kov, function (df) df[upper.tri(df, diag = FALSE)])),
sex_similarity = rep(ILV_mat[[1]][upper.tri(ILV_mat[[1]], diag = FALSE)], 3),
age_similarity = rep(ILV_mat[[2]][upper.tri(ILV_mat[[2]], diag = FALSE)], 3),
#GR = rep(gr[upper.tri(gr, diag = FALSE)], 3),
HI_similarity = c(HI[,c(1:3)]),
node_id_1 = unlist(one),
node_id_2 = unlist(two))
# Read in data
result_df <- readRDS("result_df.RData")
# Make dummy variables
result_df$BG <- ifelse(result_df$HI == "BG", 1, 0)
result_df$FG <- ifelse(result_df$HI == "FG", 1, 0)
result_df$SD <- ifelse(result_df$HI == "SD", 1, 0)
# Make factor variables
result_df$HI <- as.factor(result_df$HI)
result_df$Period <- as.factor(result_df$Period)
# Read in social association matrix and listed data
sim_HI <- readRDS("sim_HI.RData") # HI Sim Matrix
ILV_mat <-readRDS("ILV_mat.RData") # Age and Sex Matrices
kov <- readRDS("kov.RDS")  # Home range overlap
nxn <- readRDS("nxn.RData") # Association Matrix
# Prepare random effect for MCMC
num_nodes <- lapply(nxn, function(df) dim(df)[1])
node_names <- lapply(nxn, function(df) colnames(df))
# Separate IDs into i and j
node_ids_i <- lapply(num_nodes, function(df) matrix(rep(1:df, each = df), nrow = df, ncol = df))
node_ids_j <- lapply(node_ids_i, function(df) t(df))
# Format data
upper_tri <- lapply(nxn, function(df) upper.tri(df, diag = FALSE))
edge_nxn <- abind(lapply(nxn, function(mat) mat[upper.tri(mat, diag = FALSE)]), along = 2)
## Split by 3 for int data
HAB_data <- as.data.frame(cbind(c(edge_nxn[,1], edge_nxn[,2], edge_nxn[,3]), c(rep(1, nrow(edge_nxn)), rep(2, nrow(edge_nxn)), rep(3, nrow(edge_nxn)))))
colnames(HAB_data) <- c("SRI", "HAB")
HAB_data$During <- ifelse(HAB_data$HAB == 2, 1, 0)
HAB_data$After <- ifelse(HAB_data$HAB == 3, 1, 0)
HI <- abind(lapply(sim_HI, function(mat) mat[upper.tri(mat, diag = FALSE)]), along = 2)
one <- lapply(seq_along(node_ids_i), function(i) factor(as.vector(node_names[[i]][node_ids_i[[i]][upper_tri[[i]]]]), levels = node_names[[i]]))
two <- lapply(seq_along(node_ids_j), function(i) factor(as.vector(node_names[[i]][node_ids_j[[i]][upper_tri[[i]]]]), levels = node_names[[i]]))
# Put data into a dataframe
df_list = data.frame(edge_weight = HAB_data[, 1],
HAB_During = HAB_data[, 3],
HAB_After = HAB_data[, 4],
HRO = unlist(lapply(kov, function (df) df[upper.tri(df, diag = FALSE)])),
sex_similarity = rep(ILV_mat[[1]][upper.tri(ILV_mat[[1]], diag = FALSE)], 3),
age_similarity = rep(ILV_mat[[2]][upper.tri(ILV_mat[[2]], diag = FALSE)], 3),
#GR = rep(gr[upper.tri(gr, diag = FALSE)], 3),
HI_similarity = c(HI[,c(1:3)]),
node_id_1 = unlist(one),
node_id_2 = unlist(two))
# Check distribution
hist(df_list$edge_weight)
