# Other survival objects
oc_juv <- 0.3
coast_juv <- 0.6
# Make empty matrix with zeros
age_matrix <- matrix(0, 21, 21)
# Ocean juvenile
age_matrix[2,1] = oc_juv
age_matrix[3,2] = oc_juv
# Small coastal juvenile
age_matrix[4,3] = coast_juv
age_matrix[5,4] = coast_juv
age_matrix[6,5] = coast_juv
# Large coastal juvenile
age_matrix[7,6] = surv_juv
age_matrix[8,7] = surv_juv
age_matrix[9,8] = surv_juv
age_matrix[10,9] = surv_juv
age_matrix[11,10] = surv_juv
# Adult
age_matrix[12,11] = surv_adult
age_matrix[13,12] = surv_adult
age_matrix[14,13] = surv_adult
age_matrix[15,14] = surv_adult
age_matrix[16,15] = surv_adult
age_matrix[17,16] = surv_adult
age_matrix[18,17] = surv_adult
age_matrix[19,18] = surv_adult
age_matrix[20,19] = surv_adult
age_matrix[21,20] = surv_adult
age_matrix[21,21] = surv_adult
# Fertility
age_matrix[1,11:21] = fert_adult
age_matrix[1,9] = fert_juv
# Initial population
initial_pop <- c(10000, 0, 0, 0)
# Simulate population growth
pop_growth <- matrix(0, 21, 20) # Empty vector
pop_growth[, 1] <- initial_pop # Initial pop
pop_growth
# Initial population
initial_pop <- c(10000, rep(0, 20))
# Simulate population growth
pop_growth <- matrix(0, 21, 20) # Empty vector
pop_growth[, 1] <- initial_pop # Initial pop
pop_growth
# Initial population
initial_pop <- c(10000, rep(0, 20))
# Simulate population growth
years <- 20
pop_growth <- matrix(0, 21, years) # Empty vector
pop_growth[, 1] <- initial_pop # Initial pop
for (t in 1:(years - 1)) {
pop_growth[, t + 1] <- age_matrix %*% pop_growth[, t]
}
pop_growth
colSums(pop_growth[10:21,])
# Only total adults starting at age 10
adult_pop <- colSums(pop_growth[10:21,])
# Plot this over time
time <- 1:20
plot(x = time, y = adult_pop, xlab = "Time (years)", ylab = "Adult Population")
total_pop <- colSums(pop_growth)
total_pop
total_pop <- colSums(pop_growth)
N_t <- total_pop[1:19]
N_t1 <- total_pop[2:20]
lambda <- N_t1/N_t
final_lambda <- lambda[19]
# Calculate final lambda
total_pop <- colSums(pop_growth)
N_t <- total_pop[1:19]
N_t1 <- total_pop[2:20]
lambda <- N_t1/N_t
final_lambda <- lambda[19]
final_lambda
# Calculate % per year change
percent_change <- (lambda-1) * 100
percent_change[19]
# Calculate stable age distribution
stab_age <- proportions(pop_growth, 2)
stab_age
percent_change[19]
# Calculate stable age distribution
stab_age <- proportions(pop_growth, 2)
stab_age
# Calculate final lambda
total_pop <- colSums(pop_growth)
N_t <- total_pop[1:19]
N_t1 <- total_pop[2:20]
lambda <- N_t1/N_t
final_lambda <- lambda[19]
final_lambda
# Calculate % per year change
percent_change <- (lambda-1) * 100
percent_change[19]
# Calculate stable age distribution
stab_age <- proportions(pop_growth, 2)
stab_age[, 20]
# Final lambda
eigen(age_matrix)$values[1]
# Stable age distribution
eigen(age_matrix)$vectors[,1]/sum(eigen(age_matrix)$vectors[,1])
# Protect different parameters
A <- age_matrix # nests
B <- age_matrix # hatchlings
C <- age_matrix # small coastal juv
D <- age_matrix # adults
# A: Nests --------------------------------------------------
## Step 1: Change fecundity calculation with new nest_surv
nest_surv <- 0.75
fecundity_2 <- ann_nest * eggs * nest_surv * sex_ratio * prob_nest
fert_adult <- fecundity_2 * surv_adult
fert_juv <- fecundity_2 * surv_juv
## Step 2: Change fertility in matrix
A[1,11:21] = fert_adult
A[1,9] = fert_juv
## Step 3: Use eigen value to calculate final lambda
eigen(A)$values[1]
# B: Hatchlings --------------------------------------------------
## Step 1: Change ocean juv surv in matrix
oc_juv <- 0.35
B[2,1] = oc_juv
B[3,2] = oc_juv
## Step 2: Use eigen value to calculate final lambda
eigen(B)$values[1]
# C: Coastal Juv --------------------------------------------------
## Step 1: Change coastal juv surv in matrix
coast_juv <- 0.85
C[4,3] = coast_juv
C[5,4] = coast_juv
C[6,5] = coast_juv
## Step 2: Use eigen value to calculate final lambda
eigen(C)$values[1]
# D: Adults --------------------------------------------------
## Step 1: Change adult surv in matrix
surv_adult <- 0.95
fert_adult <- surv_adult * fecundity
D[12,11] = surv_adult
D[13,12] = surv_adult
D[14,13] = surv_adult
D[15,14] = surv_adult
D[16,15] = surv_adult
D[17,16] = surv_adult
D[18,17] = surv_adult
D[19,18] = surv_adult
D[20,19] = surv_adult
D[21,20] = surv_adult
D[21,21] = surv_adult
D[1,11:21] = fert_adult
## Step 2: Use eigen value to calculate final lambda
eigen(D)$values[1]
knitr::opts_chunk$set(echo = TRUE)
f_t1 * suit_patch
# Fraction occupied at time t
f_t = 0.25 #Invaded a quarter of suitable water bodies
# Probability of local colonization
p_i = 0.1 # 10% per year
# Immigration
I = p_i * (1 - f_t) # prob of occ * available space
#' Change in fraction over time
#' All currently occupied water bodies will remain occupied
#' over the year so E = I
dfdt = I
# f(t+1) = f(t) + f(t) * df/dt
f_t1 = f_t + f_t * dfdt
# Fraction multiplied by the number of suitable water bodies
suit_patch <- 200
f_t1 * suit_patch
f_t1
f_t1 * suit_patch
f_t * suit_patch
#' Take the difference in between the fraction occupied in
#' the next year and the fraction occupied in the current
#' year
f_t1 * suit_patch - f_t * suit_patch
#' This
knitr::opts_chunk$set(echo = TRUE)
# Fraction occupied at time t
f_t = 0.25 #Invaded a quarter of suitable water bodies
# Probability of local colonization
p_i = 0.1 # 10% per year
# Immigration
I = p_i * (1 - f_t) # prob of occ * available space
#' Change in fraction over time
#' All currently occupied water bodies will remain occupied
#' over the year so E = I
dfdt = I
# f(t+1) = f(t) + f(t) * df/dt
f_t1 = f_t + f_t * dfdt
# Fraction multiplied by the number of suitable water bodies
suit_patch <- 200
f_t1 * suit_patch # fraction occupied next year
f_t1
# Vary nest survival
nest_surv <- seq(0.1, 0.7, 0.1)
offspring_prob_nest <- ann_nest * eggs * nest_surv * sex_ratio * prob_nest * adult_life_span
# Vary adult female lifespan
adult_life_span <- seq(5, 30, 5)
offspring_prob_female <- ann_nest * eggs * 0.1 * sex_ratio * prob_nest * adult_life_span
# Plot the graphs in 2D
plot(x = nest_surv, y = offspring_prob_nest,
xlab = "Nest Survival Rate",
ylab = "Offspring Production", type = "l")
plot(x = adult_life_span, y = offspring_prob_female,
xlab = "Adult Lifespan",
ylab = "Offspring Production", type = "l")
# Now make both vary
offspring <- function(x, y) {
offspring_prob <- ann_nest * eggs * x * sex_ratio *
prob_nest * y
return(offspring_prob)
}
offspring_prob <- outer(adult_life_span, nest_surv, offspring)
rownames(offspring_prob) <- adult_life_span
colnames(offspring_prob) <- nest_surv
# 3D graph
persp(x = adult_life_span, y = nest_surv, z = offspring_prob,
xlab = "Adult Lifespan", ylab = "Nest Survival Rate",
zlab = "Offspring Production", ticktype="detailed")
ann_nest <- 4
eggs <- 100
nest_surv <- 0.1
sex_ratio <- 0.65
ann_nest * eggs * nest_surv * sex_ratio
prob_nest <- 0.4
ann_nest * eggs * nest_surv * sex_ratio * prob_nest
adult_life_span <- 20
ann_nest * eggs * nest_surv * sex_ratio *
prob_nest * adult_life_span
# Vary nest survival
nest_surv <- seq(0.1, 0.7, 0.1)
offspring_prob_nest <- ann_nest * eggs * nest_surv * sex_ratio * prob_nest * adult_life_span
# Vary adult female lifespan
adult_life_span <- seq(5, 30, 5)
offspring_prob_female <- ann_nest * eggs * 0.1 * sex_ratio * prob_nest * adult_life_span
# Plot the graphs in 2D
plot(x = nest_surv, y = offspring_prob_nest,
xlab = "Nest Survival Rate",
ylab = "Offspring Production", type = "l")
plot(x = adult_life_span, y = offspring_prob_female,
xlab = "Adult Lifespan",
ylab = "Offspring Production", type = "l")
# Now make both vary
offspring <- function(x, y) {
offspring_prob <- ann_nest * eggs * x * sex_ratio *
prob_nest * y
return(offspring_prob)
}
offspring_prob <- outer(adult_life_span, nest_surv, offspring)
rownames(offspring_prob) <- adult_life_span
colnames(offspring_prob) <- nest_surv
# 3D graph
persp(x = adult_life_span, y = nest_surv, z = offspring_prob,
xlab = "Adult Lifespan", ylab = "Nest Survival Rate",
zlab = "Offspring Production", ticktype="detailed")
# Look at the 3D matrix
offspring_prob # Should be 0.4 for offspring > 1000
nest_surv <- 0.4
plot(adult_life_span,
1000/(adult_life_span * ann_nest *
eggs * nest_surv * sex_ratio *
prob_nest * adult_life_span))
vital_rates <- read.csv("VitalRates.csv")
vital_rates
# This is a post-breeding census
fecundity <- ann_nest * eggs * nest_surv * sex_ratio * prob_nest
surv_adult <- 0.9
surv_juv <- 0.8
fert_adult <- fecundity * surv_adult
fert_juv <- fecundity * surv_juv
# Other survival objects
oc_juv <- 0.3
coast_juv <- 0.6
# Make empty matrix with zeros
age_matrix <- matrix(0, 21, 21)
# Ocean juvenile
age_matrix[2, 1] = oc_juv
age_matrix[3, 2] = oc_juv
# Small coastal juvenile
age_matrix[4, 3] = coast_juv
age_matrix[5, 4] = coast_juv
age_matrix[6, 5] = coast_juv
# Large coastal juvenile
age_matrix[7, 6] = surv_juv
age_matrix[8, 7] = surv_juv
age_matrix[9, 8] = surv_juv
age_matrix[10, 9] = surv_juv
age_matrix[11, 10] = surv_juv
# Adult
age_matrix[12, 11] = surv_adult
age_matrix[13, 12] = surv_adult
age_matrix[14, 13] = surv_adult
age_matrix[15, 14] = surv_adult
age_matrix[16, 15] = surv_adult
age_matrix[17, 16] = surv_adult
age_matrix[18, 17] = surv_adult
age_matrix[19, 18] = surv_adult
age_matrix[20, 19] = surv_adult
age_matrix[21, 20] = surv_adult
age_matrix[21, 21] = surv_adult
# Fertility
age_matrix[1, 11:21] = fert_adult
age_matrix[1, 9] = fert_juv
# Initial population
initial_pop <- c(10000, rep(0, 20))
# Simulate population growth
years <- 20
pop_growth <- matrix(0, 21, years) # Empty vector
pop_growth[, 1] <- initial_pop # Initial pop
for (t in 1:(years - 1)) {
pop_growth[, t + 1] <- age_matrix %*% pop_growth[, t]
}
pop_growth
# Only total adults starting at age 10
adult_pop <- colSums(pop_growth[11:21,])
# Plot this over time
time <- 1:20
plot(x = time, y = adult_pop, xlab = "Time (years)", ylab = "Adult Population", type = "b")
# Calculate final lambda
total_pop <- colSums(pop_growth)
N_t <- total_pop[1:19]
N_t1 <- total_pop[2:20]
lambda <- N_t1/N_t
final_lambda <- lambda[19]
final_lambda
# Calculate % per year change
percent_change <- (lambda-1) * 100
percent_change[19]
# Calculate stable age distribution
stab_age <- proportions(pop_growth, 2)
stab_age[, 20]
# Final lambda
lambda <- eigen(age_matrix)$values[1]
lambda
# Percent per year change
percent_change <- (lambda-1) * 100
# Stable age distribution
stable_age <- eigen(age_matrix)$vectors[,1]/sum(eigen(age_matrix)$vectors[,1])
stable_age
# Protect different parameters
A <- age_matrix # nests
B <- age_matrix # hatchlings
C <- age_matrix # small coastal juv
D <- age_matrix # adults
# A: Nests --------------------------------------------------
## Step 1: Change fecundity calculation with new nest_surv
nest_surv <- 0.75
fecundity_2 <- ann_nest * eggs * nest_surv * sex_ratio * prob_nest
fert_adult <- fecundity_2 * surv_adult
fert_juv <- fecundity_2 * surv_juv
## Step 2: Change fertility in matrix
A[1,11:21] = fert_adult
A[1,10] = fert_juv
## Step 3: Use eigen value to calculate final lambda
lambda_A <- eigen(A)$values[1]
# B: Hatchlings --------------------------------------------------
## Step 1: Change ocean juv surv in matrix
oc_juv <- 0.35
B[2,1] = oc_juv
B[3,2] = oc_juv
## Step 2: Use eigen value to calculate final lambda
lambda_B <- eigen(B)$values[1]
# C: Coastal Juv --------------------------------------------------
## Step 1: Change coastal juv surv in matrix
coast_juv <- 0.85
C[4,3] = coast_juv
C[5,4] = coast_juv
C[6,5] = coast_juv
## Step 2: Use eigen value to calculate final lambda
lambda_C <- eigen(C)$values[1]
# D: Adults --------------------------------------------------
## Step 1: Change adult surv in matrix
surv_adult <- 0.95
fert_adult <- surv_adult * fecundity
D[12,11] = surv_adult
D[13,12] = surv_adult
D[14,13] = surv_adult
D[15,14] = surv_adult
D[16,15] = surv_adult
D[17,16] = surv_adult
D[18,17] = surv_adult
D[19,18] = surv_adult
D[20,19] = surv_adult
D[21,20] = surv_adult
D[21,21] = surv_adult
D[1,11:21] = fert_adult
## Step 2: Use eigen value to calculate final lambda
lambda_D <- eigen(D)$values[1]
data.frame(Plan = c("original", "A", "B", "C", "D"),
Lambda = c(lambda, lambda_A, lambda_B,
lambda_C, lambda_D))
#' Plan C of requiring Turtle Excluder Devices that protect small
#' coastal juveniles, increasing their survival to 85% was the best
#' plan with the highest population growth increase from the original
# Fraction occupied at time t
f_t = 0.25 #Invaded a quarter of suitable water bodies
# Probability of local colonization
p_i = 0.1 # 10% per year
# Immigration
I = p_i * (1 - f_t) # prob of occ * available space
#' Change in fraction over time
#' All currently occupied water bodies will remain occupied
#' over the year so E = 0
dfdt = I
# f(t+1) = f(t) + f(t) * df/dt
f_t1 = f_t + f_t * dfdt
# Fraction multiplied by the number of suitable water bodies
suit_patch <- 200
f_t1 * suit_patch # fraction occupied next year
#' Take the difference in between the fraction occupied in
#' the next year and the fraction occupied in the current
#' year
f_t1 * suit_patch - f_t * suit_patch
#' This is the number of occupied patches that need to be
#' extirpated to prevent any increase in patch occupancy
#' in the next year
knitr::opts_chunk$set(echo = TRUE)
# Protect different parameters
A <- age_matrix # nests
B <- age_matrix # hatchlings
C <- age_matrix # small coastal juv
D <- age_matrix # adults
# A: Nests --------------------------------------------------
## Step 1: Change fecundity calculation with new nest_surv
nest_surv <- 0.75
fecundity_2 <- ann_nest * eggs * nest_surv * sex_ratio * prob_nest
fert_adult <- fecundity_2 * surv_adult
fert_juv <- fecundity_2 * surv_juv
## Step 2: Change fertility in matrix
A[1,11:21] = fert_adult
A[1,10] = fert_juv
## Step 3: Use eigen value to calculate final lambda
lambda_A <- eigen(A)$values[1]
# B: Hatchlings --------------------------------------------------
## Step 1: Change ocean juv surv in matrix
oc_juv <- 0.35
B[2,1] = oc_juv
B[3,2] = oc_juv
## Step 2: Use eigen value to calculate final lambda
lambda_B <- eigen(B)$values[1]
# C: Coastal Juv --------------------------------------------------
## Step 1: Change coastal juv surv in matrix
coast_juv <- 0.85
C[4,3] = coast_juv
C[5,4] = coast_juv
C[6,5] = coast_juv
## Step 2: Use eigen value to calculate final lambda
lambda_C <- eigen(C)$values[1]
# D: Adults --------------------------------------------------
## Step 1: Change adult surv in matrix
surv_adult <- 0.95
fert_adult <- surv_adult * fecundity
D[12,11] = surv_adult
D[13,12] = surv_adult
D[14,13] = surv_adult
D[15,14] = surv_adult
D[16,15] = surv_adult
D[17,16] = surv_adult
D[18,17] = surv_adult
D[19,18] = surv_adult
D[20,19] = surv_adult
D[21,20] = surv_adult
D[21,21] = surv_adult
D[1,11:21] = fert_adult
## Step 2: Use eigen value to calculate final lambda
lambda_D <- eigen(D)$values[1]
fert_adult
lambda_D
D
gc()
# Set working directory here
setwd("../data")
setwd("C:/Users/bankh/My_Repos/Dolphins/code")
# Set working directory here
setwd("../data")
kov <- readRDS("kov.RDS")  # Home range overlap
gr <- readRDS("kinship_matrix.RData")
# Check multicollinearity
cor(gr, kov[[1]])
# Check multicollinearity
mantel(gr, kov[[1]])
library(asnipe) # get_group_by_individual--Damien Farine
library(assocInd) # Could do permutatioNP
library(vegan)
library(assortnet) # associative indices
library(kinship2) # genetic relatedness
library(ggplot2) # Visualization
library(abind) # array
library(brms) # For brm model
library(coda)
library(bayesplot) # plot parameters
library(sf) # Convert degrees to meters
library(sp) # Creates a SpatialPointsDataFrame by defining the coordinates
library(adehabitatHR) # Caluculate MCPs and Kernel density
library(magrittr) # All below is for STAN
library(dplyr)
library(purrr)
library(forcats)
library(tidyr)
library(modelr)
library(ggdist)
library(tidybayes)
library(cowplot)
library(rstan) # To make STAN run faster
library(ggrepel)
library(RColorBrewer)
library(gganimate)
library(posterior)
library(distributional)
library(doParallel)
# Check multicollinearity
mantel(gr, kov[[1]])
