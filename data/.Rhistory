for (i in 1:yrs) {
colonization<- colonize(persistance = persistance)
persistance<- p(p.mean, p.sd, ic = colonization[i])
vect<-c(vect,mean(persistance))
}
return(vect)
}
newt.occ<- final.occ(yrs = 10)
final.occ<- function(yrs){
initial.occupancy<- o(mn = 0.7, s = 0.2)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
vect<- NULL
for (i in 1:yrs) {
colonization<- colonize(persistance = persistance)
persistance<- p(180, 70, ic = colonization[i])
vect<-c(vect,mean(persistance))
}
return(vect)
}
newt.occ<- final.occ(yrs = 10)
newt.occ
# Change persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(1,cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
#' Mouse dynamics function
mouse.patch.dyn_vect<-function(N.suitable,N.unsuit,years, decision){
#   N.suitable=50
#   N.unsuit=50
#   years=50
# set initial values
p.colon.hat<- 0.5
p.colon.var<- 0.1
beta.colon<-beta.mom(p.colon.hat,p.colon.var)
p.persist.hat=0.75
time=0
# initial occupancy
occ.states<-initial_occup_vect(p.persist=p.persist.hat,p.colon=p.colon.hat, N.suitable=N.suitable)
# place to hold proportion occupied
for(yr in 1:years){
# implement decision in year 5
decis<- ifelse(yr==5,decision,1)
hurricane<-rbinom(length(N.suitable),1,0.02)
p.persist=change.persistence_vect(decision=decis,hurricane=hurricane)
p.colon<-rbeta(length(N.suitable),beta.colon[1],beta.colon[2])
# if nothing is occupied colonization is zero
p.colon<-ifelse(occ.states > 0,p.colon,0)
occ.states<- colon_extinct_vect(p.persist=p.persist,N.occupied.t=occ.states,
p.colon=p.colon, N.empty.t=(N.suitable-occ.states))
tmp<-veg.dynamics_vect(N.suitable=N.suitable,N.unsuit=N.unsuit,time=time,
hurricane=hurricane)
N.suitable=tmp[,1]
N.unsuit=tmp[,2]
time=tmp[,3]
# restore 5 patches decision
N.suitable=ifelse(decis==3, N.suitable+5, N.suitable)
Total.ptch = N.suitable+N.unsuit
}
occ.states<-ifelse(is.na(occ.states),0,occ.states)
return(occ.states)
}
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4)
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
# Beta Function
beta.mom<-function(mean,v){
x<-mean
a<-x*(x*(1-x)/v-1)
b<-(1-x)*(x*(1-x)/v-1)
c(a,b)}
# Extinction
colon_extinct_vect<-function(p.persist,N.occupied.t,p.colon, N.empty.t){
N.occupied.t.plus<-rbinom(length(N.occupied.t),N.occupied.t,p.persist)+
rbinom(length(N.empty.t),N.empty.t,p.colon)
return(c(N.occupied.t.plus))}
# Initial Occupancy
initial_occup_vect<-function(p.persist,p.colon, N.suitable){
p.initial<- p.colon/(p.colon + (1-p.persist))
N.occupied.t<-rbinom(length(N.suitable),N.suitable,p.initial)
return(c(N.occupied.t))}
# Change Persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(length(hurricane),cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(1,1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
# Veg dynamics
veg.dynamics_vect<-function(N.suitable,N.unsuit,time,hurricane){
Total.patch= N.suitable + N.unsuit
N.unsuit <- N.unsuit + ifelse(hurricane==1,rbinom(length(N.suitable),N.suitable,0.5),0)
N.suitable <- Total.patch - N.unsuit
time <- ifelse(hurricane==1, 0, time + 1)
wt.slow<-0.5
wt.fast<- 1- wt.slow
p.suitable<- 1/(1+exp(-(-5 + 0.05*time + 0.05*time^2)))*wt.slow +
1/(1+exp(-(-5 + 0.75*time)))*wt.fast
N.suitable <- N.suitable + rbinom(length(N.suitable),N.unsuit,p.suitable)
N.unsuit<- Total.patch - N.suitable
veg.data<- cbind(N.suitable,N.unsuit,time)
return(veg.data)}
# Change persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(1,cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
#' Mouse dynamics function
mouse.patch.dyn_vect<-function(N.suitable,N.unsuit,years, decision){
#   N.suitable=50
#   N.unsuit=50
#   years=50
# set initial values
p.colon.hat<- 0.5
p.colon.var<- 0.1
beta.colon<-beta.mom(p.colon.hat,p.colon.var)
p.persist.hat=0.75
time=0
# initial occupancy
occ.states<-initial_occup_vect(p.persist=p.persist.hat,p.colon=p.colon.hat, N.suitable=N.suitable)
# place to hold proportion occupied
for(yr in 1:years){
# implement decision in year 5
decis<- ifelse(yr==5,decision,1)
hurricane<-rbinom(length(N.suitable),1,0.02)
p.persist=change.persistence_vect(decision=decis,hurricane=hurricane)
p.colon<-rbeta(length(N.suitable),beta.colon[1],beta.colon[2])
# if nothing is occupied colonization is zero
p.colon<-ifelse(occ.states > 0,p.colon,0)
occ.states<- colon_extinct_vect(p.persist=p.persist,N.occupied.t=occ.states,
p.colon=p.colon, N.empty.t=(N.suitable-occ.states))
tmp<-veg.dynamics_vect(N.suitable=N.suitable,N.unsuit=N.unsuit,time=time,
hurricane=hurricane)
N.suitable=tmp[,1]
N.unsuit=tmp[,2]
time=tmp[,3]
# restore 5 patches decision
N.suitable=ifelse(decis==3, N.suitable+5, N.suitable)
Total.ptch = N.suitable+N.unsuit
}
occ.states<-ifelse(is.na(occ.states),0,occ.states)
return(occ.states)
}
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
dec.1
# Change Persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(length(hurricane),cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
# Change persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(1,cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
#' Mouse dynamics function
mouse.patch.dyn_vect<-function(N.suitable,N.unsuit,years,decision){
# set initial values
p.colon.hat<- 0.5
p.colon.var<- 0.1
beta.colon<-beta.mom(p.colon.hat,p.colon.var)
p.persist.hat=0.75
time=0
# initial occupancy
occ.states<-initial_occup_vect(p.persist=p.persist.hat,p.colon=p.colon.hat, N.suitable=N.suitable)
# place to hold proportion occupied
for(yr in 1:years){
# implement decision in year 5
decis<- ifelse(yr==5,decision,1)
hurricane<-rbinom(length(N.suitable),1,0.02)
p.persist=change.persistence_vect(decision=decis,hurricane=hurricane)
p.colon<-rbeta(length(N.suitable),beta.colon[1],beta.colon[2])
# if nothing is occupied colonization is zero
p.colon<-ifelse(occ.states > 0,p.colon,0)
occ.states<- colon_extinct_vect(p.persist=p.persist,N.occupied.t=occ.states,
p.colon=p.colon, N.empty.t=(N.suitable-occ.states))
tmp<-veg.dynamics_vect(N.suitable=N.suitable,N.unsuit=N.unsuit,time=time,
hurricane=hurricane)
N.suitable=tmp[,1]
N.unsuit=tmp[,2]
time=tmp[,3]
# restore 5 patches decision
N.suitable=ifelse(decis==3, N.suitable+5, N.suitable)
Total.ptch = N.suitable+N.unsuit
}
occ.states<-ifelse(is.na(occ.states),0,occ.states)
return(occ.states)
}
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
dec.1
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
dec.1
vect <- rnorm(100, 30, 2)
# Stop the cluster
stopCluster(cl)
library(parallel)
library(doParallel)
# Stop the cluster
stopCluster(cl)
stopImplicitCluster()
# Specify the number of nodes/workers in the cluster
num_nodes <- 2
# Create a cluster with the specified number of nodes/workers
cl <- makeCluster(num_nodes)
# Stop the cluster
stopCluster(cl)
knitr::opts_chunk$set(echo = TRUE)
# Set working directory here
setwd("C:/Users/bankh/My_Repos/Dolphins/data")
## load all necessary packages
require(ade4) # Look at Dai Shizuka/Jordi Bascompte
require(ncf) # For weights
require(vegan)
# Read file in to retain ILV
sample_data <- read.csv("sample_data.csv")
kov <- readRDS("kov.RDS")
# Read in social association matrix and data
nxn <- readRDS("nxn.RData")
list_years <- readRDS("list_years.RData")
# Transforming SRI similarity into distance
year <- 5
dolp_dist = nxn[[year]] + 0.00001
dolp_dist <- 1-nxn[[year]]
## Remove the redundant cells and the diagonal
dolp_dist <- as.dist(dolp_dist)
# Select variables from the raw data
data <- list_years[[year]]
aux <- data[, c('Code', 'Behaviors', 'HumanInteraction', 'ConfHI')]
length(unique(aux$Code)) # individuals should stay consistent
# Use 'Behaviors' variable to extract "Feed" and create another variable with two classes (Feed, Other)
aux$Foraging <- "Other"
aux$Foraging[grepl(pattern = 'Feed',
x = aux$Behaviors,
ignore.case = FALSE, perl = FALSE,
fixed = FALSE, useBytes = FALSE)] = "Feed"
#aux <- subset(aux, aux$Foraging == "Feed")
aux$ConfHI <- ifelse(aux$ConfHI == "0", 0, 1)
# Categorize ID to Foraging
IDbehav <- table(aux$Code, aux$Foraging)
IDbehav <- as.data.frame(IDbehav, stringsAsFactors = FALSE)
IDbehav <- IDbehav[,c(1,3)]
colnames(IDbehav) <- c("Code", "Forg_Freq")
# Group by the 'Code' column and sum the frequencies
IDbehav <- aggregate(. ~ Code, data = IDbehav, sum)
# Categorize ConfHI to IDs
rawHI <- as.matrix(table(aux$Code, aux$ConfHI))
rawHI <- as.data.frame(rawHI, stringsAsFactors = FALSE)
colnames(rawHI) <- c("Code", "ConfHI", "Freq")
## Add up the # of times each ID was seen in HI
IDbehav$HI <- rawHI$Freq[rawHI$ConfHI != 0]
IDdata <- IDbehav
colnames(IDdata) <- c("Code", "Foraging", "HI")
## Proportion of time Foraging spent in HI
IDdata$HIprop <- as.numeric(IDdata$HI)/as.numeric(IDdata$Foraging)
IDdata[is.na(IDdata)] <- 0
# Only ID to prop
HIprop_ID <- IDdata[,c(1, 4)]
# Dissimilarity of HI proportion among individual dolphins, using Euclidean distance
fake_HIprop <- HIprop_ID$HIprop
dissimilarity_HI <- as.matrix(dist(as.matrix(fake_HIprop), method = "euclidean"))
dissimilarity_HI[is.na(dissimilarity_HI)] <- 0
# Dissimilarity of HI proportion among individual dolphins, using Euclidean distance
fake_HIprop <- HIprop_ID$HIprop
dissimilarity_HI <- as.matrix(dist(as.matrix(fake_HIprop), method = "euclidean"))
dissimilarity_HI[is.na(dissimilarity_HI)] <- 0
# Dissimilarity matrices
HI_test <- mantel.rtest(dolp_dist, dissimilarity_HI, kov, nrepet = 1000)
dissimilarity_HI <- as.dist(dissimilarity_HI) # HI dissimilarity
kov <- as.dist(kov) # Home range overlap
# Dissimilarity matrices
HI_test <- mantel.rtest(dolp_dist, dissimilarity_HI, kov, nrepet = 1000)
dissimilarity_HI <- as.dist(dissimilarity_HI) # HI dissimilarity
kov <- as.dist(kov) # Home range overlap
# Dissimilarity matrices
## HRO
hro_test <- mantel.rtest(dolp_dist, kov, nrepet = 1000)
plot(hro_test)
## HI
HI_test <- mantel.rtest(dolp_dist, dissimilarity_HI, nrepet = 1000)
plot(HI_test)
# Set working directory here
setwd("C:/Users/bankh/My_Repos/Dolphins/data")
###########################################################################
# PART 1: Create HI Similarity Matrix  ------------------------------------------------
## load all necessary packages
require(ade4) # Look at Dai Shizuka/Jordi Bascompte
require(ncf) # For weights
require(vegan)
# Read file in to retain ILV
sample_data <- read.csv("sample_data.csv")
View(sample_data)
# Read in social association matrix and data
nxn <- readRDS("nxn.RData")
list_years <- readRDS("list_years.RData")
# Transforming SRI similarity into distance
year <- 5
# Select variables from the raw data
data <- list_years[[year]]
aux <- data[, c('Code', 'Behaviors', 'HumanInteraction', 'ConfHI')]
# Use 'Behaviors' variable to extract "Feed" and create another variable with two classes (Feed, Other)
aux$Foraging <- "Other"
aux$Foraging[grepl(pattern = 'Feed',
x = aux$Behaviors,
ignore.case = FALSE, perl = FALSE,
fixed = FALSE, useBytes = FALSE)] = "Feed"
# Categorize ID to Foraging
IDbehav <- table(aux$Code, aux$Foraging)
IDbehav
IDbehav <- as.data.frame(IDbehav, stringsAsFactors = FALSE)
IDbehav <- IDbehav[,c(1,3)]
colnames(IDbehav) <- c("Code", "Forg_Freq")
# Group by the 'Code' column and sum the frequencies
IDbehav <- aggregate(. ~ Code, data = IDbehav, sum)
# Categorize ConfHI to IDs
rawHI <- as.matrix(table(aux$Code, aux$ConfHI))
rawHI
rawHI <- as.data.frame(rawHI, stringsAsFactors = FALSE)
# Categorize ConfHI to IDs
rawHI <- as.matrix(table(aux$Code, aux$ConfHI))
# HI behaviors should be partitioned into 3 different types
#' B = Begging (direct provisioning): F, G, H
#' P = patrolling/scavenging (indirect): A, B, C
#' D = foraging around fixed gear (humans not present):D, E, P
ifelse(aux$ConfHI == c("F", "G", "H"), "B", ifelse(aux$ConfHI == c("A", "B", "C"), "P", aux$ConfHI == c("F", "G", "H"), "D"), 0)
# HI behaviors should be partitioned into 3 different types
#' B = Begging (direct provisioning): F, G, H
#' P = patrolling/scavenging (indirect): A, B, C
#' D = foraging around fixed gear (humans not present):D, E, P
ifelse(aux$ConfHI == c("F", "G", "H"), "B", ifelse(aux$ConfHI == c("A", "B", "C"), "P", aux$ConfHI == c("F", "G", "H"), "D"), "0")
# HI behaviors should be partitioned into 3 different types
#' B = Begging (direct provisioning): F, G, H
#' P = patrolling/scavenging (indirect): A, B, C
#' D = foraging around fixed gear (humans not present):D, E, P
# Fix the code using ifelse statements
aux$ConfHI <- ifelse(aux$ConfHI %in% c("F", "G", "H"), "B",
ifelse(aux$ConfHI %in% c("A", "B", "C"), "P", "D", "0"))
# HI behaviors should be partitioned into 3 different types
#' B = Begging (direct provisioning): F, G, H
#' P = patrolling/scavenging (indirect): A, B, C
#' D = foraging around fixed gear (humans not present):D, E, P
# Fix the code using ifelse statements
aux$ConfHI <- ifelse(aux$ConfHI %in% c("F", "G", "H"), "B",
ifelse(aux$ConfHI %in% c("A", "B", "C"), "P", "D"))
aux$ConfHI
View(aux)
aux <- data[, c('Code', 'Behaviors', 'HumanInteraction', 'ConfHI')]
# Use 'Behaviors' variable to extract "Feed" and create another variable with two classes (Feed, Other)
aux$Foraging <- "Other"
aux$Foraging[grepl(pattern = 'Feed',
x = aux$Behaviors,
ignore.case = FALSE, perl = FALSE,
fixed = FALSE, useBytes = FALSE)] = "Feed"
# HI behaviors should be partitioned into 3 different types
#' B = Begging (direct provisioning): F, G, H
#' P = patrolling/scavenging (indirect): A, B, C
#' D = foraging around fixed gear (humans not present):D, E, P
# Fix the code using ifelse statements
aux$ConfHI <- ifelse(aux$ConfHI %in% c("F", "G", "H"), "B",
ifelse(aux$ConfHI %in% c("A", "B", "C"), "P",
ifelse(aux$ConfHI %in% c("A", "B", "C"), "D", "0")))
View(aux)
# Categorize ConfHI to IDs
rawHI <- as.matrix(table(aux$Code, aux$ConfHI))
rawHI
aux <- data[, c('Code', 'Behaviors', 'HumanInteraction', 'ConfHI')]
# Use 'Behaviors' variable to extract "Feed" and create another variable with two classes (Feed, Other)
aux$Foraging <- "Other"
aux$Foraging[grepl(pattern = 'Feed',
x = aux$Behaviors,
ignore.case = FALSE, perl = FALSE,
fixed = FALSE, useBytes = FALSE)] = "Feed"
# HI behaviors should be partitioned into 3 different types
#' B = Begging (direct provisioning): F, G, H
#' P = patrolling/scavenging (indirect): A, B, C
#' D = foraging around fixed gear (humans not present):D, E, P
# Fix the code using ifelse statements
aux$ConfHI <- ifelse(aux$ConfHI %in% c("F", "G", "H"), "B",
ifelse(aux$ConfHI %in% c("A", "B", "C"), "P",
ifelse(aux$ConfHI %in% c("D", "E", "P"), "D", "0")))
# Categorize ConfHI to IDs
rawHI <- as.matrix(table(aux$Code, aux$ConfHI))
rawHI
rawHI <- as.data.frame(rawHI, stringsAsFactors = FALSE)
rawHI
colnames(rawHI) <- c("Code", "ConfHI", "Freq")
## Add up the # of times each ID was seen in HI
IDbehav$HI <- rawHI$Freq[rawHI$ConfHI != 0]
## Add up the # of times each ID was seen in HI
IDbehav$HI <- rawHI$Freq[rawHI$ConfHI != "0"]
rawHI$Freq[rawHI$ConfHI != "0"]
# Categorize ID to Foraging
IDbehav <- table(aux$Code, aux$Foraging)
IDbehav <- as.data.frame(IDbehav, stringsAsFactors = FALSE)
IDbehav <- IDbehav[,c(1,3)]
colnames(IDbehav) <- c("Code", "Forg_Freq")
# Group by the 'Code' column and sum the frequencies
IDbehav <- aggregate(. ~ Code, data = IDbehav, sum)
## Add up the # of times each ID was seen in HI
IDbehav$HI <- rawHI$Freq[rawHI$ConfHI != "0" && rawHI$ConfHI == "B"]
rawHI$Freq[rawHI$ConfHI != "0" && rawHI$ConfHI == "B"]
rawHI$Freq[rawHI$ConfHI != "0" | rawHI$ConfHI == "B"]
## Add up the # of times each ID was seen in HI
IDbehav$HI <- rawHI$Freq[rawHI$ConfHI != "0" | rawHI$ConfHI == "B"]
rawHI$Freq[rawHI$ConfHI == "B" & rawHI$ConfHI != "0"]
## Add up the # of times each ID was seen in HI
IDbehav$HI <- rawHI$Freq[rawHI$ConfHI == "B" & rawHI$ConfHI != "0"]
IDdata <- IDbehav
colnames(IDdata) <- c("Code", "Foraging", "HI")
## Proportion of time Foraging spent in HI
IDdata$HIprop <- as.numeric(IDdata$HI)/as.numeric(IDdata$Foraging)
IDdata[is.na(IDdata)] <- 0
# Only ID to prop
HIprop_ID <- IDdata[,c(1, 4)]
# Dissimilarity of HI proportion among individual dolphins, using Euclidean distance
fake_HIprop <- HIprop_ID$HIprop
dissimilarity_HI <- as.matrix(dist(as.matrix(fake_HIprop), method = "euclidean"))
dissimilarity_HI[is.na(dissimilarity_HI)] <- 0
dissimilarity_HI <- as.dist(dissimilarity_HI) # HI dissimilarity
# Dissimilarity matrices
HI_test <- mantel.rtest(dolp_dist, dissimilarity_HI, nrepet = 1000)
dolp_dist = nxn[[year]] + 0.00001
dolp_dist <- 1-nxn[[year]]
## Remove the redundant cells and the diagonal
dolp_dist <- as.dist(dolp_dist)
# Dissimilarity matrices
HI_test <- mantel.rtest(dolp_dist, dissimilarity_HI, nrepet = 1000)
plot(HI_test)
HI_test
## Add up the # of times each ID was seen in HI
HI <- "P"
IDbehav$HI <- rawHI$Freq[rawHI$ConfHI == HI & rawHI$ConfHI != "0"]
IDdata <- IDbehav
colnames(IDdata) <- c("Code", "Foraging", "HI")
## Proportion of time Foraging spent in HI
IDdata$HIprop <- as.numeric(IDdata$HI)/as.numeric(IDdata$Foraging)
IDdata[is.na(IDdata)] <- 0
# Only ID to prop
HIprop_ID <- IDdata[,c(1, 4)]
# Dissimilarity of HI proportion among individual dolphins, using Euclidean distance
fake_HIprop <- HIprop_ID$HIprop
dissimilarity_HI <- as.matrix(dist(as.matrix(fake_HIprop), method = "euclidean"))
dissimilarity_HI[is.na(dissimilarity_HI)] <- 0
dissimilarity_HI <- as.dist(dissimilarity_HI) # HI dissimilarity
# Dissimilarity matrices
HI_test <- mantel.rtest(dolp_dist, dissimilarity_HI, nrepet = 1000)
plot(HI_test)
## Add up the # of times each ID was seen in HI
HI <- "D"
IDbehav$HI <- rawHI$Freq[rawHI$ConfHI == HI & rawHI$ConfHI != "0"]
IDdata <- IDbehav
colnames(IDdata) <- c("Code", "Foraging", "HI")
## Proportion of time Foraging spent in HI
IDdata$HIprop <- as.numeric(IDdata$HI)/as.numeric(IDdata$Foraging)
IDdata[is.na(IDdata)] <- 0
# Only ID to prop
HIprop_ID <- IDdata[,c(1, 4)]
# Dissimilarity of HI proportion among individual dolphins, using Euclidean distance
fake_HIprop <- HIprop_ID$HIprop
dissimilarity_HI <- as.matrix(dist(as.matrix(fake_HIprop), method = "euclidean"))
dissimilarity_HI[is.na(dissimilarity_HI)] <- 0
dissimilarity_HI <- as.dist(dissimilarity_HI) # HI dissimilarity
# Dissimilarity matrices
HI_test <- mantel.rtest(dolp_dist, dissimilarity_HI, nrepet = 1000)
plot(HI_test)
HI_test
