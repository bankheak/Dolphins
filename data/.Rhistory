##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 1:800
Recruits_turkey <- alpha*N*exp(-beta*N)
plot(N, Recruits_turkey, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
Recruits_grouse = 1/(alpha + beta/N)
plot(N, Recruits_grouse, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
Turkey_MSY <- which.max(Recruits_turkey - N)
Turkey_MSY
Grouse_MSY <- which.max(Recruits_grouse - N)
Grouse_MSY
t_vect <- Recruits_turkey - N
Turkey_MSY <- which.max(t_vect)
Turkey_MSY
t_vect <- Grouse_MSY - N
Grouse_MSY <- which.max(Recruits_grouse - N)
Grouse_MSY
t_vect
t_vect <- Recruits_turkey - N
Turkey_MSY <- which.max(t_vect)
Turkey_MSY
t_vect <- Grouse_MSY - N
Grouse_MSY <- which.max(Recruits_grouse - N)
Grouse_MSY
r <- 0.3
K <- 500
N0 <- 500
# H = 20
H = 20
numyears <- 50
N <- rep(NA, numyears)
N[1] <- N0
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0:600))
?plot
# H = 20
H = 20
numyears <- 50
N <- rep(NA, numyears)
N[1] <- N0
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N40_t, c(changeN20, changeN30, changeN40))
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N20_t, changeN20, type = 'l', col = 'blue', ylim = range(c(changeN20, changeN30, changeN40)), ylab = 'dN/dt', xlab = 'Population Size')
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N20_t, changeN20, type = 'l', col = 'blue', ylab = 'dN/dt', xlab = 'Population Size')
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
# Plot the first population
plot(N20_t, changeN20, type = 'l', col = 'blue', ylab = 'dN/dt', xlab = 'Time', main = 'Population Changes Over Time')
N=1:500
dndt=r * N * (1 - N/K)
plot(N,dndt,xlab="Population Size",ylab="dN/dt")
abline(h=20)
abline(h=30,lty=2)
abline(h=40,lty=3)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N,dndt,xlab="Population Size",ylab="dN/dt")
abline(h=20)
abline(h=30,lty=2)
abline(h=40,lty=3)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(h = 20, lyt = 2)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20, lyt = 2)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
?abline
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20)
abline(h = 30, lty = 2, lwd = 1.5)
abline(h = 40, lty = 2)
F_m = 0.2
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.3
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.4
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.2
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size")
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 1)))
(max(N_small) + 50)
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
N_small
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 50)))
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_med) + 1)))
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_large) + 1)))
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size")
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size")
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size")
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(0, 0.2)
abline(0, 0.3, lty=2)
abline(0, 0.4, lty=3)
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N_20, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
N_30[1] <- N0
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N_30, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
N_40[1] <- N0
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N_40, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
gc()
gc()
# Set working directory here
setwd("../data")
# Read in data
result_df <- readRDS("result_df.RData")
# Make period a factor
result_df$Period <- as.factor(result_df$Period)
# Make ID numeric
result_df$numeric_ID <- as.numeric(factor(result_df$ID))
# Make sure there is only one ID in each period
result_df <- result_df[!duplicated(result_df[c("Period", "ID")]), ]
# Check assumptions of model
## Visualize relationship
plot(result_df$Strength ~ result_df$Prop_BG)
plot(result_df$Strength ~ result_df$Prop_FG)
plot(result_df$Strength ~ result_df$Prop_SD)
library(ggalluvial) # For alluvial plot
library(rstatix) # for post-hoc test
library(bayesboot) # bootstraping
library(tnet) # For weights
library(igraph) # Measure centrality here
library(ggraph)
library(ggpattern) # geom_tile_pattern
library(grid)
library(assortnet) # associative indices
library(ggplot2) # Visualization
library(abind) # array
library(boot) # bootstrapping
library(brms) # For brm modellibrary(coda)
library(bayesplot) # plot parameters
library(doParallel) # Run parallel processing
library(hrbrthemes) # plot themes
library(viridis) # plot themes
library(ggpattern) # heatmap hatches
library(car) # durbinWatsonTest
library(rstan) # To make STAN run faster
library(tidybayes) # get_variables
library(dplyr)
# Help STAN run faster
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit_brm.4 <- brm(Strength ~
Prop_BG * Period +
Prop_FG * Period +
Prop_SD * Period +
(1 | numeric_ID),
chains = 10, iter = 4000, warmup = 2000,
family = gaussian, data = result_df)
summary(fit_brm.4)
# Check for model convergence
model <- fit_brm.4
plot(model)
pp_check(model) # check to make sure they line up
## Period Centrality
theme_update(text = element_text(family = "sans"))
# Create mcmc_areas plot
mcmc_plot <- mcmc_areas(
as.array(model),
pars = c("b_Period2MDuring_HAB", "b_Period3MAfter_HAB"),
prob = 0.95, # 95% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) + labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 95% intervals"
) + theme_update(text = element_text(family = "sans"))
mcmc_plot + scale_y_discrete(
labels = c(
"b_Period2MDuring_HAB" = "During",
"b_Period3MAfter_HAB" = "After"
)
) +
theme(panel.background = element_blank())
## BG
# Create mcmc_areas plot
mcmc_plot <- mcmc_areas(
as.array(model),
pars = c("b_Prop_BG:Period2MDuring_HAB", "b_Prop_BG:Period3MAfter_HAB",
"b_Prop_BG"),
prob = 0.95, # 95% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) + labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 95% intervals"
) + theme_update(text = element_text(family = "sans"))
mcmc_plot + scale_y_discrete(
labels = c(
"b_Prop_BG" = "Begging/Provisioning",
"b_Prop_BG:Period2MDuring_HAB" = "BG: During",
"b_Prop_BG:Period3MAfter_HAB" = "BG: After"
)
) +
theme(panel.background = element_blank())
## FG
mcmc_plot <- mcmc_areas(
as.array(model),
pars = c("b_Period2MDuring_HAB:Prop_FG", "b_Period3MAfter_HAB:Prop_FG",
"b_Prop_FG"),
prob = 0.95, # 95% intervals
prob_outer = 0.99, # 99%
point_est = "mean"
) + labs(
title = "Posterior parameter distributions",
subtitle = "with medians and 95% intervals"
) + theme_update(text = element_text(family = "sans"))
mcmc_plot + scale_y_discrete(
labels = c(
"b_Prop_FG" = "Fixed Gear Foraging",
"b_Period2MDuring_HAB:Prop_FG" = "FG: During",
"b_Period3MAfter_HAB:Prop_FG" = "FG: After"
)
) +
theme(panel.background = element_blank())
kernel <- readRDS("kernel.RData")
# Set working directory here
setwd("../data")
# Google tiles (requires a key first)
## Guide on getting a key: https://www.r-bloggers.com/geocoding-with-ggmap-and-the-google-api/
register_google(key = "AIzaSyAgFfxIJmkL8LAWE7kHCqSqKBQDvqa9umI")
library(sf) # Convert degrees to meters
library(sp) # Creates a SpatialPointsDataFrame by defining the coordinates
library(adehabitatHR) # Caluculate MCPs and Kernel density
library(scales) # Helps make polygons partly transparent using the alpha argument
library(ggmap) # Download tiles using ggmap
library(viridis) # Color pallette
library(gridExtra) # grid.arrange function
library(ggplot2)
library(rgdal) # Overlap
# Google tiles (requires a key first)
## Guide on getting a key: https://www.r-bloggers.com/geocoding-with-ggmap-and-the-google-api/
register_google(key = "AIzaSyAgFfxIJmkL8LAWE7kHCqSqKBQDvqa9umI")
# Read in file
list_years <- readRDS("list_years.RData")
# Make coordinate data
dolph.data <- lapply(list_years, function (df) {
# Read in only ID, x, and y
df <- df[, c("Code", "StartLon", "StartLat")]
# Create a SpatialPointsDataFrame by defining the coordinates
coordinates(df) <- c("StartLon", "StartLat")
# Set the coordinate reference system (CRS)
# More information on CRS here:
# https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/OverviewCoordinateReferenceSystems.pdf
proj4string(df) <- CRS( "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs" )
df
})
# Calculate MCPs for each dolphin
dolph.mcp <- lapply(dolph.data, function (df) mcp(df, percent = 100))
plot(dolph.data[[1]], col = as.factor(dolph.data[[1]]@data$id), pch = 16)
# Transform the point and MCP objects.
dolph.spgeo <- lapply(dolph.data, function (df) spTransform(df, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs")))
dolph.mcpgeo <- lapply(dolph.mcp, function (df) spTransform(df, CRS("+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs")))
mybasemap <- get_map(location = c(lon = mean(dolph.spgeo[[1]]@coords[,1]),
lat = mean(dolph.spgeo[[1]]@coords[,2])),
source = "google",
zoom = 10,
maptype = 'satellite')
mymap_with_kde <- mybasemap +
stat_contour(data = as.data.frame(kernel[[1]]),
aes(x = x, y = y, z = level),
bins = 10,
geom = "polygon",
alpha = 0.5,
color = "red") +
labs(title = "Kernel Density Estimate")
image(kernel[[1]])
library(dplyr)
library(adehabitatHR)
library(ggplot2)
library(magrittr)
library(leaflet)
plot(getverticeshr(kernel[[1]], percent = 75), add = TRUE)
plot(kernel[[1]])
image(kernel[[1]])
plot(getverticeshr(kernel[[1]], percent = 75), add = TRUE)
# creating SpatialPolygonsDataFrame
kd_names <- names(kd)
# creating SpatialPolygonsDataFrame
kd_names <- names(kernel[[1]])
kd_names
kd <- kernel[[1]]
# creating SpatialPolygonsDataFrame
kd_names <- names(kd)
ud <- lapply(kd, function(x) try(getverticeshr(x, 95)))
