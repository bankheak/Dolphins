occ.states<-initial_occup_vect(p.persist=p.persist.hat,p.colon=p.colon.hat, N.suitable=N.suitable)
# place to hold proportion occupied
for(yr in 1:years){
# implement decision in year 5
decis<- ifelse(yr==5,decision,1)
hurricane<-rbinom(length(N.suitable),1,0.02)
p.persist=change.persistence_vect(decision=decis,hurricane=hurricane)
p.colon<-rbeta(length(N.suitable),beta.colon[1],beta.colon[2])
# if nothing is occupied colonization is zero
p.colon<-ifelse(occ.states > 0,p.colon,0)
occ.states<- colon_extinct_vect(p.persist=p.persist,N.occupied.t=occ.states,
p.colon=p.colon, N.empty.t=(N.suitable-occ.states))
tmp<-veg.dynamics_vect(N.suitable=N.suitable,N.unsuit=N.unsuit,time=time,
hurricane=hurricane)
N.suitable=tmp[,1]
N.unsuit=tmp[,2]
time=tmp[,3]
# restore 5 patches decision
N.suitable=ifelse(decis==3, N.suitable+5, N.suitable)
Total.ptch = N.suitable+N.unsuit
}
occ.states<-ifelse(is.na(occ.states),0,occ.states)
return(occ.states)
}
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4)
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
# Beta Function
beta.mom<-function(mean,v){
x<-mean
a<-x*(x*(1-x)/v-1)
b<-(1-x)*(x*(1-x)/v-1)
c(a,b)}
# Extinction
colon_extinct_vect<-function(p.persist,N.occupied.t,p.colon, N.empty.t){
N.occupied.t.plus<-rbinom(length(N.occupied.t),N.occupied.t,p.persist)+
rbinom(length(N.empty.t),N.empty.t,p.colon)
return(c(N.occupied.t.plus))}
# Initial Occupancy
initial_occup_vect<-function(p.persist,p.colon, N.suitable){
p.initial<- p.colon/(p.colon + (1-p.persist))
N.occupied.t<-rbinom(length(N.suitable),N.suitable,p.initial)
return(c(N.occupied.t))}
# Change Persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(length(hurricane),cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(1,1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
# Veg dynamics
veg.dynamics_vect<-function(N.suitable,N.unsuit,time,hurricane){
Total.patch= N.suitable + N.unsuit
N.unsuit <- N.unsuit + ifelse(hurricane==1,rbinom(length(N.suitable),N.suitable,0.5),0)
N.suitable <- Total.patch - N.unsuit
time <- ifelse(hurricane==1, 0, time + 1)
wt.slow<-0.5
wt.fast<- 1- wt.slow
p.suitable<- 1/(1+exp(-(-5 + 0.05*time + 0.05*time^2)))*wt.slow +
1/(1+exp(-(-5 + 0.75*time)))*wt.fast
N.suitable <- N.suitable + rbinom(length(N.suitable),N.unsuit,p.suitable)
N.unsuit<- Total.patch - N.suitable
veg.data<- cbind(N.suitable,N.unsuit,time)
return(veg.data)}
# Change persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(1,cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
#' Mouse dynamics function
mouse.patch.dyn_vect<-function(N.suitable,N.unsuit,years, decision){
#   N.suitable=50
#   N.unsuit=50
#   years=50
# set initial values
p.colon.hat<- 0.5
p.colon.var<- 0.1
beta.colon<-beta.mom(p.colon.hat,p.colon.var)
p.persist.hat=0.75
time=0
# initial occupancy
occ.states<-initial_occup_vect(p.persist=p.persist.hat,p.colon=p.colon.hat, N.suitable=N.suitable)
# place to hold proportion occupied
for(yr in 1:years){
# implement decision in year 5
decis<- ifelse(yr==5,decision,1)
hurricane<-rbinom(length(N.suitable),1,0.02)
p.persist=change.persistence_vect(decision=decis,hurricane=hurricane)
p.colon<-rbeta(length(N.suitable),beta.colon[1],beta.colon[2])
# if nothing is occupied colonization is zero
p.colon<-ifelse(occ.states > 0,p.colon,0)
occ.states<- colon_extinct_vect(p.persist=p.persist,N.occupied.t=occ.states,
p.colon=p.colon, N.empty.t=(N.suitable-occ.states))
tmp<-veg.dynamics_vect(N.suitable=N.suitable,N.unsuit=N.unsuit,time=time,
hurricane=hurricane)
N.suitable=tmp[,1]
N.unsuit=tmp[,2]
time=tmp[,3]
# restore 5 patches decision
N.suitable=ifelse(decis==3, N.suitable+5, N.suitable)
Total.ptch = N.suitable+N.unsuit
}
occ.states<-ifelse(is.na(occ.states),0,occ.states)
return(occ.states)
}
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
dec.1
# Change Persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(length(hurricane),cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
# Change persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(1,cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
#' Mouse dynamics function
mouse.patch.dyn_vect<-function(N.suitable,N.unsuit,years,decision){
# set initial values
p.colon.hat<- 0.5
p.colon.var<- 0.1
beta.colon<-beta.mom(p.colon.hat,p.colon.var)
p.persist.hat=0.75
time=0
# initial occupancy
occ.states<-initial_occup_vect(p.persist=p.persist.hat,p.colon=p.colon.hat, N.suitable=N.suitable)
# place to hold proportion occupied
for(yr in 1:years){
# implement decision in year 5
decis<- ifelse(yr==5,decision,1)
hurricane<-rbinom(length(N.suitable),1,0.02)
p.persist=change.persistence_vect(decision=decis,hurricane=hurricane)
p.colon<-rbeta(length(N.suitable),beta.colon[1],beta.colon[2])
# if nothing is occupied colonization is zero
p.colon<-ifelse(occ.states > 0,p.colon,0)
occ.states<- colon_extinct_vect(p.persist=p.persist,N.occupied.t=occ.states,
p.colon=p.colon, N.empty.t=(N.suitable-occ.states))
tmp<-veg.dynamics_vect(N.suitable=N.suitable,N.unsuit=N.unsuit,time=time,
hurricane=hurricane)
N.suitable=tmp[,1]
N.unsuit=tmp[,2]
time=tmp[,3]
# restore 5 patches decision
N.suitable=ifelse(decis==3, N.suitable+5, N.suitable)
Total.ptch = N.suitable+N.unsuit
}
occ.states<-ifelse(is.na(occ.states),0,occ.states)
return(occ.states)
}
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
dec.1
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
dec.1
vect <- rnorm(100, 30, 2)
# Stop the cluster
stopCluster(cl)
library(parallel)
library(doParallel)
# Stop the cluster
stopCluster(cl)
stopImplicitCluster()
# Specify the number of nodes/workers in the cluster
num_nodes <- 2
# Create a cluster with the specified number of nodes/workers
cl <- makeCluster(num_nodes)
# Stop the cluster
stopCluster(cl)
nF <-  readRDS("../code/nF.RData")
# Set working directory here
setwd("C:/Users/bankh/My_Repos/Dolphins/data")
nF <-  readRDS("../code/nF.RData")
# Read file in
gbi <-  readRDS("../data/gbi.RData")
library(parallel)
library(doParallel)
library(foreach)
gbi <- gbi[[1]][c(1:50), c(1:50)]
# Load Null function
null <- function (mat, iter, ...){
library(vegan)
aux <- permatswap(mat, times=iter, method="quasiswap", fixedmar="both",
shuffle="both", mtype="prab")
return(aux$perm)
}
# Load SRI function
SRI.func<-  function (matr) {
if (any(is.na(matr))) {
matr <- na.omit(matr)
cat("The data matrix contains NA, and have been removed.\n")
}
matr1 = matr
N <- nrow(matr1)
matr1[matr1 > 1] <- 1
n <- apply(matr1, 2, sum)
tmatr <- t(matr1)
df <- as.matrix(t(matr))
a <- df %*% t(df) # Dyad in same group
b <- df %*% (1 - t(df)) # A present, B absent
c <- (1 - df) %*% t(df) # A absent, B present
d <- ncol(df) - a - b - c # Double absent
Dice <- data.frame()
for (i in 1:nrow(a)) {
for (j in 1:ncol(a)) {
Dice[i, j] <- a[i, j]/(a[i, j] + b[i, j] + c[i, j])
}
}
rownames(Dice)=colnames(Dice)=colnames(matr)
Dice
}
# Parallel processing
reps <- 1000
#nF <- list()
#for (i in 1:22) {
#nF[[i]] <-
nF<- null(gbi, iter=reps)
#' Calculate the association and CV for each of the 1000 permuted matrices to
#' create null distribution
cv_null <- rep(NA,reps)
#cv_null_years <- list()
#for (j in 1:22) {
foreach(i = 1:reps, .combine = c) %dopar% {
sri_null = as.matrix(SRI.func(nF))
cv_null[i] <- ( sd(sri_null) / mean(sri_null) ) * 100}
# Create a cluster with the specified number of nodes/workers
cl <- makeCluster(num_nodes)
# Specify the number of nodes/workers in the cluster
num_nodes <- 4
# Create a cluster with the specified number of nodes/workers
cl <- makeCluster(num_nodes)
# Register the cluster to enable parallel processing
registerDoParallel(cl)
#cv_null_years <- list()
#for (j in 1:22) {
foreach(i = 1:reps, .combine = c) %dopar% {
sri_null = as.matrix(SRI.func(nF))
cv_null[i] <- ( sd(sri_null) / mean(sri_null) ) * 100}
# Stop the cluster
stopCluster(cl)
#cv_null_years <- list()
#for (j in 1:22) {
foreach(i = 1:reps, .combine = c) %dopar% {
sri_null = as.matrix(SRI.func(nF[[i]]))
cv_null[i] <- ( sd(sri_null) / mean(sri_null) ) * 100}
nF[[1]]
#cv_null_years <- list()
#for (j in 1:22) {
foreach(i = 1:reps,
.combine = c) %dopar% {
sri_null = as.matrix(SRI.func(nF[[i]]))
cv_null[i] <- ( sd(sri_null) / mean(sri_null) ) * 100}
# Register the cluster to enable parallel processing
registerDoParallel(cl)
#cv_null_years <- list()
#for (j in 1:22) {
foreach(i = 1:reps,
.combine = c) %dopar% {
sri_null = as.matrix(SRI.func(nF[[i]]))
cv_null[i] <- ( sd(sri_null) / mean(sri_null) ) * 100}
gc()
# Read file in
gbi <-  readRDS("../data/gbi.RData")
gbi <- gbi[[1]][c(1:50), c(1:50)]
# Specify the number of nodes/workers in the cluster
num_nodes <- 4
# Create a cluster with the specified number of nodes/workers
cl <- makeCluster(num_nodes)
# Register the cluster to enable parallel processing
registerDoParallel(cl)
# Load Null function
null <- function (mat, iter, ...){
library(vegan)
aux <- permatswap(mat, times=iter, method="quasiswap", fixedmar="both",
shuffle="both", mtype="prab")
return(aux$perm)
}
# Load SRI function
SRI.func<-  function (matr) {
if (any(is.na(matr))) {
matr <- na.omit(matr)
cat("The data matrix contains NA, and have been removed.\n")
}
matr1 = matr
N <- nrow(matr1)
matr1[matr1 > 1] <- 1
n <- apply(matr1, 2, sum)
tmatr <- t(matr1)
df <- as.matrix(t(matr))
a <- df %*% t(df) # Dyad in same group
b <- df %*% (1 - t(df)) # A present, B absent
c <- (1 - df) %*% t(df) # A absent, B present
d <- ncol(df) - a - b - c # Double absent
Dice <- data.frame()
for (i in 1:nrow(a)) {
for (j in 1:ncol(a)) {
Dice[i, j] <- a[i, j]/(a[i, j] + b[i, j] + c[i, j])
}
}
rownames(Dice)=colnames(Dice)=colnames(matr)
Dice
}
# Parallel processing
reps <- 1000
#nF <- list()
#for (i in 1:22) {
#nF[[i]] <-
nF<- null(gbi, iter=reps)
#' Calculate the association and CV for each of the 1000 permuted matrices to
#' create null distribution
cv_null <- rep(NA,reps)
#cv_null_years <- list()
#for (j in 1:22) {
foreach(i = 1:reps,
.combine = c) %dopar% {
sri_null = as.matrix(SRI.func(nF[[i]]))
cv_null[i] <- ( sd(sri_null) / mean(sri_null) ) * 100}
# Stop the cluster
stopCluster(cl)
#' Calculate the association and CV for each of the 1000 permuted matrices to
#cv_null_years <- list()
#for (j in 1:22) {
cv_null <- foreach(i = 1:reps,
.combine = c) %dopar% {
sri_null = as.matrix(SRI.func(nF[[i]]))
cv_null[i] <- ( sd(sri_null) / mean(sri_null) ) * 100}
gc()
# Read file in
gbi <-  readRDS("../data/gbi.RData")
gbi <- gbi[[1]][c(1:50), c(1:50)]
# Specify the number of nodes/workers in the cluster
num_nodes <- 4
# Create a cluster with the specified number of nodes/workers
cl <- makeCluster(num_nodes)
# Register the cluster to enable parallel processing
registerDoParallel(cl)
# Load Null function
null <- function (mat, iter, ...){
library(vegan)
aux <- permatswap(mat, times=iter, method="quasiswap", fixedmar="both",
shuffle="both", mtype="prab")
return(aux$perm)
}
# Load SRI function
SRI.func<-  function (matr) {
if (any(is.na(matr))) {
matr <- na.omit(matr)
cat("The data matrix contains NA, and have been removed.\n")
}
matr1 = matr
N <- nrow(matr1)
matr1[matr1 > 1] <- 1
n <- apply(matr1, 2, sum)
tmatr <- t(matr1)
df <- as.matrix(t(matr))
a <- df %*% t(df) # Dyad in same group
b <- df %*% (1 - t(df)) # A present, B absent
c <- (1 - df) %*% t(df) # A absent, B present
d <- ncol(df) - a - b - c # Double absent
Dice <- data.frame()
for (i in 1:nrow(a)) {
for (j in 1:ncol(a)) {
Dice[i, j] <- a[i, j]/(a[i, j] + b[i, j] + c[i, j])
}
}
rownames(Dice)=colnames(Dice)=colnames(matr)
Dice
}
# Parallel processing
reps <- 1000
#nF <- list()
#for (i in 1:22) {
#nF[[i]] <-
nF<- null(gbi, iter=reps)
#' Calculate the association and CV for each of the 1000 permuted matrices to
#cv_null_years <- list()
#for (j in 1:22) {
cv_null <- foreach(i = 1:reps,
.combine = c) %dopar% {
sri_null = as.matrix(SRI.func(nF[[i]]))
cv_null[i] <- ( sd(sri_null) / mean(sri_null) ) * 100}
#' Calculate the association and CV for each of the 1000 permuted matrices to
#' create null distribution
cv_null <- rep(NA,reps)
#cv_null_years <- list()
#for (j in 1:22) {
cv_null <- foreach(i = 1:reps,
.combine = c) %dopar% {
sri_null = as.matrix(SRI.func(nF[[i]]))
cv_null[i] <- ( sd(sri_null) / mean(sri_null) ) * 100}
class(cv_null)
# Stop the cluster
stopCluster(cl)
gc()
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
class(cv_null)
View(cv_null)
## Remove NAs, if any
cv_null = cv_null[!is.na(cv_null)]
# Read in null cv values for one year
cv_null <- as.vector(read.csv("../data/cv_null.csv", header = FALSE))
View(cv_null)
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
View(cv_null)
## Remove NAs, if any and turn into vector
cv_null = na.omit(cv_null)
## Remove NAs, if any and turn into vector
na.omit(cv_null)
View(cv_null)
cv_null <- cv_null$V2
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
## Remove NAs, if any and turn into vector
na.omit(cv_null)
cv_null <- as.vector(cv_null[,2])
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
## Remove NAs, if any and turn into vector
na.omit(cv_null)
cv_null <- as.numeric(cv_null[,2])
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
## Remove NAs, if any and turn into vector
na.omit(cv_null)
cv_null <- as.vector(unlist(as.numeric(cv_null[,2])))
# Read in null cv values for one year
cv_null <- as.vector(unlist(read.csv("../data/cv_null.csv", header = FALSE)))
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
cv_null <- cv_null[c(2:1001), 2]
## Remove NAs, if any
cv_null = cv_null[!is.na(cv_null)]
cv_null
class(cv_null)
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
cv_null <- as.numeric(cv_null[c(2:1001), 2])
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
na.omit(cv_null)
cv_null <- as.vector(unlist(as.numeric(cv_null[c(2:1001), 2])))
# Read in null cv values for one year
cv_null <- as.vector(unlist(read.csv("../data/cv_null.csv", header = FALSE)))
# Read in null cv values for one year
cv_null <- unlist(read.csv("../data/cv_null.csv", header = FALSE))
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
## Remove square brackets and their contents using regular expressions
clean_string <- gsub("\\[.*?\\]", "", cv_null)
## Split the string into individual elements
elements <- unlist(strsplit(clean_string, " "))
## Convert the elements to numeric values
cv_null <- as.numeric(elements)
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
cv_null <- cv_null[2:1001, 2]
cv_null <- as.numeric(cv_null[2:1001, 2])
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
cv_null <- as.numeric(cv_null[2:1001, 2])
## Remove NAs, if any
cv_null = cv_null[!is.na(cv_null)]
class(cv_null)
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
cv_null <- as.numeric(cv_null[2:1001, 2])
## Remove NAs, if any
cv_null = cv_null[!is.na(cv_null)]
cv_null
# Read in null cv values for one year
cv_null <- read.csv("../data/cv_null.csv", header = FALSE)
cv_null <- c(as.numeric(cv_null[2:1001, 2]))
cv_null <- c(cv_null)
