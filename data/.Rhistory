K = 500
MSY= r * K/4
MSY
#' The max of logistic growth curve is r*K/4,
#' which can be found by plugging in K/2 for N in rN (1 - N/K)
r = 0.6
K = 500
N = K/2
MSY = r * N * (1 - N/K)
MSY
K = 250
r = 0.08
r * N * (1 - N/K)
K = 250
r = 0.08
r*K/4
#' The max of logistic growth curve is r*K/4,
#' which can be found by plugging in K/2 for N in rN (1 - N/K)
r = 0.6
K = 500
N = K/2
MSY = r * N * (1 - N/K)
MSY
r*K/4
#' The max of logistic growth curve is r*K/4,
#' which can be found by plugging in K/2 for N in rN (1 - N/K)
r = 0.6
K = 500
N = K/2
MSY = r * N * (1 - N/K)
MSY
K = 250
r = 0.08
N = K/2
r * N * (1 - N/K)
r = 0.11
K = 11500 * 2
N = 11500
same <- r * N * (1 - N/K)
# dN/dt - rN(1-(N/K))
N = 14000
change <- r*N*(1-N/K)
change - same
##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 1:800
Recruits_turkey <- alpha*N*exp(-beta*N)
plot(N, Recruits_turkey, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
Recruits_grouse = 1/(alpha + beta/N)
plot(N, Recruits_grouse, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
max(Recruits_turkey)
max(Recruits_grouse)
##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 1:800
Recruits_turkey <- alpha*N*exp(-beta*N)
plot(N, Recruits_turkey, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
Recruits_grouse = 1/(alpha + beta/N)
plot(N, Recruits_grouse, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
##The Ricker function: Recruits  = alpha*N*exp(-beta*N)
# 8 wild turkeys
alpha <-  7
beta <- 0.003448
N = 1:800
Recruits_turkey <- alpha*N*exp(-beta*N)
plot(N, Recruits_turkey, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
##The Beverton-Holt function has various equivalent forms.
##In this problem use Recruits = 1/(alpha + beta/N)
# 14 ruffed grouse
alpha <- 0.0012
beta <- 0.35
Recruits_grouse = 1/(alpha + beta/N)
plot(N, Recruits_grouse, xlab = "Population Size", ylab = "Expected Recruitment")
abline(0,1)
Turkey_MSY <- which.max(Recruits_turkey - N)
Turkey_MSY
Grouse_MSY <- which.max(Recruits_grouse - N)
Grouse_MSY
t_vect <- Recruits_turkey - N
Turkey_MSY <- which.max(t_vect)
Turkey_MSY
t_vect <- Grouse_MSY - N
Grouse_MSY <- which.max(Recruits_grouse - N)
Grouse_MSY
t_vect
t_vect <- Recruits_turkey - N
Turkey_MSY <- which.max(t_vect)
Turkey_MSY
t_vect <- Grouse_MSY - N
Grouse_MSY <- which.max(Recruits_grouse - N)
Grouse_MSY
r <- 0.3
K <- 500
N0 <- 500
# H = 20
H = 20
numyears <- 50
N <- rep(NA, numyears)
N[1] <- N0
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0:600))
?plot
# H = 20
H = 20
numyears <- 50
N <- rep(NA, numyears)
N[1] <- N0
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N40_t, c(changeN20, changeN30, changeN40))
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N20_t, changeN20, type = 'l', col = 'blue', ylim = range(c(changeN20, changeN30, changeN40)), ylab = 'dN/dt', xlab = 'Population Size')
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
plot(N20_t, changeN20, type = 'l', col = 'blue', ylab = 'dN/dt', xlab = 'Population Size')
dt <- 1
# H = 20
N20_t <- N_20[1:49]
N20_t1 <- N_20[2:50]
changeN20 <- (N20_t1 - N20_t)/dt
# H = 30
N30_t <- N_30[1:49]
N30_t1 <- N_30[2:50]
changeN30 <- (N30_t1 - N30_t)/dt
# H = 40
N40_t <- N_40[1:49]
N40_t1 <- N_40[2:50]
changeN40 <- (N40_t1 - N40_t)/dt
# Plot the first population
plot(N20_t, changeN20, type = 'l', col = 'blue', ylab = 'dN/dt', xlab = 'Time', main = 'Population Changes Over Time')
N=1:500
dndt=r * N * (1 - N/K)
plot(N,dndt,xlab="Population Size",ylab="dN/dt")
abline(h=20)
abline(h=30,lty=2)
abline(h=40,lty=3)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N,dndt,xlab="Population Size",ylab="dN/dt")
abline(h=20)
abline(h=30,lty=2)
abline(h=40,lty=3)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(h = 20, lyt = 2)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20, lyt = 2)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20)
abline(h = 30, lty = 2)
abline(h = 40, lty = 2)
?abline
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt", ylim = c(0,50))
abline(h = 20)
abline(h = 30, lty = 2, lwd = 1.5)
abline(h = 40, lty = 2)
F_m = 0.2
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.3
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.4
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
F_m = 0.2
N <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N[t + 1] = N[t] + r * N[t] * (1 - N[t]/K) - F_m * N[t]
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size")
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 1)))
(max(N_small) + 50)
F_m = 0.2
N_small <- rep(NA, numyears)
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
N_small
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_small) + 50)))
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_med) + 1)))
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size", ylim = c(0, (max(N_large) + 1)))
N_small[1] <- N0
F_m = 0.2
N_small <- rep(NA, numyears)
N_small[1] <- N0
for(t in 1:(numyears-1)){
N_small[t + 1] = N_small[t] + r * N_small[t] * (1 - N_small[t]/K) - F_m * N_small[t]
}
# Plot through time
plot(1:numyears, N_small, xlab = "Years", ylab = "Population Size")
F_m = 0.3
N_med <- rep(NA, numyears)
N_med[1] <- N0
for(t in 1:(numyears-1)){
N_med[t + 1] = N_med[t] + r * N_med[t] * (1 - N_med[t]/K) - F_m * N_med[t]
}
# Plot through time
plot(1:numyears, N_med, xlab = "Years", ylab = "Population Size")
F_m = 0.4
N_large <- rep(NA, numyears)
N_large[1] <- N0
for(t in 1:(numyears-1)){
N_large[t + 1] = N_large[t] + r * N_large[t] * (1 - N_large[t]/K) - F_m * N_large[t]
}
# Plot through time
plot(1:numyears, N_large, xlab = "Years", ylab = "Population Size")
N = 1:500
dndt = r * N * (1 - N/K)
plot(N, dndt, xlab = "Population Size", ylab = "dN/dt")
abline(0, 0.2)
abline(0, 0.3, lty=2)
abline(0, 0.4, lty=3)
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 20
H = 20
numyears <- 50
N_20 <- rep(NA, numyears)
N_20[1] <- N0
for(t in 1:(numyears-1)){
N_20[t + 1] = N_20[t] + r * N_20[t] * (1 - N_20[t]/K) - H
}
# Plot through time
plot(1:numyears, N_20, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H = 30
H = 30
N_30 <- rep(NA, numyears)
N_30[1] <- N0
for(t in 1:(numyears-1)){
N_30[t + 1] = N_30[t] + r * N_30[t] * (1 - N_30[t]/K) - H
}
# Plot through time
plot(1:numyears, N_30, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
# H= 40
H = 40
N_40 <- rep(NA, numyears)
N_40[1] <- N0
for(t in 1:(numyears-1)){
N_40[t + 1] = N_40[t] + r * N_40[t] * (1 - N_40[t]/K) - H
}
# Plot through time
plot(1:numyears, N_40, xlab = "Years", ylab = "Population Size", ylim = c(0,600))
gc()
gc()
# Set working directory here
setwd("../data")
# Read in ig object
net <- readRDS("net.RData")
# Only show IDs of HI dolphins
HI_list <- readRDS("HI_list.RData")
HI_list <- HI_list[-4] # Get rid of natural foragers
HI_IDs <- unique(as.vector(unlist(HI_list))) # Put them all together
#----Modularity---
# igraph format with weight
el_years <- readRDS("el_years.RData")
dolphin_ig <- lapply(nxn, function (mtx)
graph_from_adjacency_matrix(as.matrix(mtx),
mode="undirected",
weighted=TRUE, diag=FALSE))
# Create an unweighted network
dolp_ig <- lapply(el_years, function (el) {
ig <- graph_from_edgelist(el[,1:2])
# Add the edge weights to this network
E(ig)$weight <- as.numeric(el[,3])
# Create undirected network
ig <- as.undirected(ig)
return(ig)
}
)
ibrary(statnet)
# Load all necessary packages
library(statnet)
dolphin_ig <- lapply(nxn, function (mtx)
graph_from_adjacency_matrix(as.matrix(mtx),
mode="undirected",
weighted=TRUE, diag=FALSE))
nxn <- readRDS("nxn.RData") # association matrix of list_years
dolphin_ig <- lapply(nxn, function (mtx)
graph_from_adjacency_matrix(as.matrix(mtx),
mode="undirected",
weighted=TRUE, diag=FALSE))
library(ggnetwork) # Get cluster coords
library(ggforce) # for drawing lines around social clusters
library(ggOceanMaps) # To map florida
library(intergraph) # To use igraph network in ggnet
library(sna) # For network
library(GGally) # For mapping networks in ggplot version = '2.2.1'
library(network) # For assigning coordinates to nodes %v%
library(igraph) # graph_from_adjacency_matrix version = '1.6.0'
library(ggmap) # register API key version = '3.0.0'
library(ggraph) # For network plotting on map
library(tnet) # For weights
library(asnipe) # get_group_by_individual--Damien Farine
library(assocInd) # Could do permutatioNP
library(vegan)
library(assortnet) # associative indices
library(kinship2) # genetic relatedness
library(ggplot2) # Visualization
library(abind) # array
library(brms) # For brm model
library(coda)
library(bayesplot) # plot parameters in mcmc_area
library(sf) # Convert degrees to meters
library(sp) # Creates a SpatialPointsDataFrame by defining the coordinates
library(adehabitatHR) # Caluculate MCPs and Kernel density
library(magrittr) # All below is for STAN
library(dplyr) # for organizing code
library(rstan) # To make STAN run faster
library(ggrepel)
library(RColorBrewer)
library(gganimate)
library(posterior) # Find the posterior sample names
library(distributional)
library(doParallel) # Faster computing
dolphin_ig <- lapply(nxn, function (mtx)
graph_from_adjacency_matrix(as.matrix(mtx),
mode="undirected",
weighted=TRUE, diag=FALSE))
# Create an unweighted network
dolp_ig <- lapply(el_years, function (el) {
ig <- graph_from_edgelist(el[,1:2])
# Add the edge weights to this network
E(ig)$weight <- as.numeric(el[,3])
# Create undirected network
ig <- as.undirected(ig)
return(ig)
}
)
newman <- readRDS("newman.RData")
# Generate a vector of colors based on the number of unique memberships
for (i in seq_along(dolp_ig)) {
# Generate a vector of colors based on the number of unique memberships
col <- rainbow(max(newman[[i]]$membership))
# Initialize the color attribute with NA
V(dolp_ig[[i]])$color <- NA
# Loop through each membership value and assign colors to corresponding vertices
for (j in 1:max(newman[[i]]$membership)){
V(dolp_ig[[i]])$color[newman[[i]]$membership == j] <- rep(col[j], sum(newman[[i]]$membership == j))
}
}
# Create an unweighted network
dolp_ig <- lapply(el_years, function (el) {
ig <- graph_from_edgelist(el[,1:2])
# Add the edge weights to this network
E(ig)$weight <- as.numeric(el[,3])
# Create undirected network
ig <- as.undirected(ig)
return(ig)
}
)
